/*****************************************************************************
 * DISCLAIMER
 *
 * This software is supplied by Renesas Electronics Corporation and is only
 * intended for use with Renesas products. No other uses are authorized.
 * This software is owned by Renesas Electronics Corporation and is protected
 * under all applicable laws, including copyright laws.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES
 * REGARDING THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY,
 * INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NON-INFRINGEMENT.  ALL SUCH WARRANTIES ARE EXPRESSLY
 * DISCLAIMED.
 *
 * TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
 * ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
 * FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES
 * FOR ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS
 * AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 *
 * Renesas reserves the right, without notice, to make changes to this
 * software and to discontinue the availability of this software.
 * By using this software, you agree to the additional terms and
 * conditions found by accessing the following link:
 * http://www.renesas.com/disclaimer
 *****************************************************************************/
/* Copyright (C) 2010 Renesas Electronics Corporation. All rights reserved.  */
/*****************************************************************************
 * System Name  : AE1-LF Car Audio Demo
 * File Name    : app_ae1.c
 * Abstract     : application for AE1-L.
 * Version      : 1.00
 * Device       : R8C/2A group, or R8C/2B group, or 78K0 group
 * Tool-Chain   : High-performance Embedded Workshop (Version 4.08.00.011)
 *              : Renesas M16C Standard Toolchain (V5.45.01)
 * OS           : none
 * H/W Platform : AE1-LF demo board
 * Description  : AE1-L communication code.
 *              :   send command;
 *              :   status process;
 *              :   initialize AE1-L;
 *              :   USB/SD plug & play
 *              :   play back
 * Operation    : none
 * Limitation   : This file can be only used as sample code for AE1-LF.
 *****************************************************************************
 * History      : May.15,2011 Ver. 1.00 First Release
 *****************************************************************************/

/*****************************************************************************
 Includes   <System Includes> , "Project Includes"
 *****************************************************************************/
#include "app_ae1.h"
#include "app_host.h"
#include "disp_widget.h"
#include "mcu_depend.h"
#include "app_evolume.h"/* Adjust volume */
#include "service_general.h"
/*****************************************************************************
 Typedef definitions
 *****************************************************************************/

/*****************************************************************************
 Macro definitions
 *****************************************************************************/
/* **** Initialize AE1 default settings definition **** */
/* ID = 00H */
#define ID00_CDB7_DETECT_USB          (U8)0x01/* CDB[7], Startup status */
#define ID00_CDB8_FILE_ORDER          (U8)0x00/* CDB[8], File system storage order */
#define ID00_CDB8_FOLDER_ORDER        (U8)0x40/* CDB[8], File system storage order */
#ifdef FIRM_VER_080_USED
#else
#define ID00_CDB8_FOLDER_ORDER_SORT   (U8)0x41/* CDB[8], File system storage order */
#endif
/* ID = 41H */
#define ID41_CDB7_USED_DECODER        (U8)0x00/* CDB[7], used decoder: MP3 */
/* ID = 50H */
#define ID50_CDB7_DAC_SELECT          (U8)0x01/* CDB[7], DAC selection */
#define ID50_CDB8_DAC_FORMAT          (U8)0x01/* CDB[8], DAC parameter */
#define ID50_CDB9_SD_IF               (U8)0x00/* CDB[9], SD I/F */
#define ID50_CDB10_SD_IF_CLK          (U8)0x09/* CDB[10], Serial flash I/F clock */
#define ID50_CDB17_MAX_FOLDER_LEVEL   (U8)0x07/* CDB[17], max folder layer number */
#define ID50_CDB18_MAX_FILE_NUM_H     (U8)0xFF/* CDB[18], max file number,MSB */
#define ID50_CDB19_MAX_FILE_NUM_L     (U8)0xFF/* CDB[19], max file number,LSB */
#ifdef  FIRM_VER_080_USED
#define ID50_CDB20_MAX_FOLDER_NUM_H   (U8)0x07/* CDB[20], max folder number,MSB */
#define ID50_CDB21_MAX_FOLDER_NUM_L   (U8)0xD0/* CDB[21], max folder number,LSB */
#else
#define ID50_CDB20_MAX_FOLDER_NUM_H   (U8)0x03/* CDB[20], max folder number,MSB */
#define ID50_CDB21_MAX_FOLDER_NUM_L   (U8)0xE7/* CDB[21], max folder number,LSB */
#endif
#define ID50_CDB22_MAX_TAG_LEN_H      (U8)0x00/* CDB[22], max tag length, MSB */
#define ID50_CDB23_MAX_TAG_LEN_L      (U8)0x40/* CDB[23], max tag length, LSB */
#define ID50_CDB24_CHAR_CODE_CONVERSE (U8)0x00/* CDB[24], character code conversion */
#ifdef  FIRM_VER_080_USED
#define ID50_CDB25_LOCAL_CODE         (U8)0x00/* CDB[25], local language code */
#define ID50_CDB26_PLAY_OPTION        (U8)0x00/* CDB[26], play option */
#define ID50_CDB27_SCANTIME           (U8)0x0A/* CDB[27], scan time */
#define ID50_CDB28_STS_FRM_LEN_H      (U8)0x80/* CDB[28], max status frame length, MSB */
#define ID50_CDB29_STS_FRM_LEN_L      (U8)0xC0/* CDB[29], max status frame length, LSB */
#define ID50_CDB30_TIMEOUT_VALUE      (U8)0x46/* CDB[30], command timeout value */
#else
#define ID50_CDB25_PLAY_OPTION        (U8)0x00/* CDB[25], play option */
#define ID50_CDB26_SCANTIME           (U8)0x0A/* CDB[26], scan time */
#define ID50_CDB27_STS_FRM_LEN_H      (U8)0x80/* CDB[27], max status frame length, MSB */
#define ID50_CDB28_STS_FRM_LEN_L      (U8)0xC0/* CDB[28], max status frame length, LSB */
#define ID50_CDB29_TIMEOUT_VALUE      (U8)0x46/* CDB[29], command timeout value */
#endif
/* ID = 53H */
#define ID53_CDB7_MAX_FILES_NUM       (U8)0x27/* CDB[7]&[8], Maximum number of files: 9999 files */
#define ID53_CDB8_MAX_FILES_NUM       (U8)0x07
#define ID53_CDB9_MAX_FILES_NUM       (U8)0x03/* CDB[9]&[10], Maximum number of folders: 999 folders */
#define ID53_CDB10_MAX_FILES_NUM      (U8)0xE7
#define ID53_CDB11_MAX_TAG_LEN        (U8)0x00/* CDB[11]&[12], Maximum tag length: 128 bytes */
#define ID53_CDB12_MAX_TAG_LEN        (U8)0x80
#define ID53_CDB13_MAX_STS_FRM_LEN    (U8)0x81/* CDB[13]&[14], Maximum status frame length: 268 bytes */
#define ID53_CDB14_MAX_STS_FRM_LEN    (U8)0x0C
#define ID53_CDB15_MAX_FOLDER_LVL     (U8)0x07/* CDB[15], Maximum number of folder levels: 8 levels */
#define ID53_CDB16_IPOD_PWR_SUSPEND   (U8)0x00/* CDB[16]&[17], iPod power (suspend): 0 */
#define ID53_CDB17_IPOD_PWR_SUSPEND   (U8)0x00
#define ID53_CDB18_IPOD_PWR_NORMAL    (U8)0x00/* CDB[18]&[19], iPod power (normal): 0 */
#define ID53_CDB19_IPOD_PWR_NORMAL    (U8)0x00
#define ID53_CDB20_IPOD_PWR_ENABLE    (U8)0x00/* CDB[20], iPod power enable: Do not enable extra power */

/* Select root folder number */
#define ROOT_FOLDER_NUM               0x02/* NOTE: MODIFY BASED ON CMD(00H) CDB8 IN
                                               FUNCTION: sendCmd_USBSDConnection()
                                             root number based on file system turns
                                             0x01: when CMD(00H) CDB8 = 00H
                                             0x02: when CMD(00H) CDB8 except 00H */

/*****************************************************************************
 Imported global variables and functions (from other files)
 *****************************************************************************/

/*****************************************************************************
 Exported global variables and functions (to be accessed by other files)
 *****************************************************************************/

/*****************************************************************************
 Private variables and functions
 *****************************************************************************/
/* *** State related definition start *** */
/* AE1 task and sub-task state definition */
e_AE1Task EgAE1Task = AE1_POWER_DOWN;/* AE1 task state */
/* Playback sub-state definition */
static e_playSubstate EgplaySubstate = IDLE;

/* Save Need Power down information */
static BOOLEAN needPowerDown = FALSE;
/* Adjust volume */
static U16 attenuationValue = (U16) 0;

/*** Connect start ***/
/* AE1-L connect guard timer */
U32 U32gAE1ConnectGuardTimer = (U32) 0;
/*** Connect end ***/

/*** Switch file & folder start ***/
/* Switch folder number */
static S16 switchFolderNum = (S16) 0;
enum_getFolderInfoCtl_type getFolderInfoCtl;
static U16 folderBufNumPrevious = (U16) 0;/* Folder number information to be gotten before current folder */
static U16 folderBufNumAfter = (U16) 0;/* Folder number information to be gotten after current folder  */
static U16 specifiedFolderNum = (U16) 0;
static U8 updateFolderBufIndex = (U8) 0;
static BOOLEAN isFolderInfoComplete = TRUE;/* TRUE, folder information gotten complete
 FALSE, folder information gotten not complete */
/* Switch file number */
static S32 switchFileNum = (S32) 0;
static U16 currentNewFolderNum = (U16) 0;/* Save new folder number when switching file */
/* Get music information used */
static U16 InfoUpdatedFileNum = (U16) 0x0000;
/* Save playback time for judge invalid file type */
static U8 prevPlaybackTime = (U8) 0;
static U8 newPlaybackTime = (U8) 0;
/*** Switch file & folder end ***/

/*** To check whether can get music information or not start ***/
BOOLEAN vCanGetMusicInfo = FALSE;
/*** To check whether can get music information or not end ***/

/* Record command when do AE1 task */
static typeCmdHeader *RecCmd;

/* Record spontaneous STS when do AE1 task */
static stsConnectStatus_type stsConnectStatus;
static stsConnectStatus_type* pstsConnectStatus =
		(stsConnectStatus_type*) &U8AE1ComRxBuf[8];
static stsUsbSdConnection_type stsUsbSdConnection;
static stsUsbSdConnection_type* pstsUsbSdConnection =
		(stsUsbSdConnection_type*) &U8AE1ComRxBuf[7];
static stsPlayback_Pause_type stsPlayback_Pause;
static stsPlayback_Pause_type* pstsPlayback_Pause =
		(stsPlayback_Pause_type*) &U8AE1ComRxBuf[8];
static stsGetFolderInfo_type* pstsGetFolderInfo =
		(stsGetFolderInfo_type*) &U8AE1ComRxBuf[8];
static stsGetNameInfo_type* pstsGetNameInfo =
		(stsGetNameInfo_type*) &U8AE1ComRxBuf[8];
static stsGetTagInfo_type* pstsGetTagInfo =
		(stsGetTagInfo_type*) &U8AE1ComRxBuf[8];
static stsTimeInfo_type stsTimeInfo;
static stsTimeInfo_type* pstsTimeInfo = (stsTimeInfo_type*) &U8AE1ComRxBuf[7];
static stsMediaInfo_type* pstsMediaInfo =
		(stsMediaInfo_type*) &U8AE1ComRxBuf[8];
static stsROMInfo_type* pstsROMInfo = (stsROMInfo_type*) &U8AE1ComRxBuf[7];
static stsComSetupInfo_type* pstsComSetupInfo =
		(stsComSetupInfo_type*) &U8AE1ComRxBuf[7];
/* *** State related definition end *** */

/* *** Command transmission related variable definition start *** */
/* command counter
 * (range: 00H to 7FH)
 * when Direction bit = 0: Increment for each command issued from the host
 * when Direction bit = 1: Increment each time a spontaneous status frame is issued
 *  */
static U8 U8gcmdCounter = (U8) 0;

/* Check playback time in cycle loop */
U16 U16gDelayInCycle = (U16) 0;
/* Re-send command delay if previous STS parameters is invalid */
U16 U16gDelayResendCmd = (U16) 0;
/* Monitor playback time for switching next file if invalid file exists */
U16 U16gMonitorPlayTime = (U16) 0;

/* Playback/Pause command parameters */
static cmdPlayback_Pause_type cmdPlaybackPausePara =
{ (U16) 0x0000,/* Specified file/folder number */
(U16) 0x0000,/* Specified position, hour */
(U8) 0x00,/* Specified position, minute */
(U8) 0x00,/* Specified position, second */
{ (U8) 0x00, (U8) 0x00, (U8) 0x00, (U8) 0x00, (U8) 0x00 }/* Resume information */
};
/* Get folder command parameters */
static cmdGetFolderInfo_type cmdGetFolderInfo =
{ CURRENT_FOLDER,/* Current folder */
(U16) 0x0000, /* Specified folder number */
};

/* Name command parameters */
static cmdGetNameInfo_type cmdGetNameInfo =
{ (U8) 0x00,/* Target */
(U8) 0x00,/* Current */
(U16) 0x0000, /* Specified number */
};

/* Get Tag information command parameters */
static cmdGetTagInfo_type cmdGetTagInfo =
{ (U8) 0x00,/* tagType */
(U8) 0x00,/* target */
(U16) 0x0000, /* file number */
};

/* Temporary information for resume judgment */
static mediaInfo_type tempMediaInfo;/* Temporary media information */
/* Playback mode code based on host command
 *   PlaybackModeCodeTable[Random][Scan][Repeat]*/
static const U8 PlaybackModeCodeTable[2][2][5] =
{
{
{
/* | Random | Scan   |Repeat
 * | ON OFF | ON OFF |
 *      OFF      OFF        */MODE_FOLDER_NORMAL, /* SingleFolder */
MODE_FOLDER_REPEAT, /* CycleFolder */
MODE_ONE_FILE_REPEAT, /* SingleFile */
MODE_ALL_FILES_NORMAL, /* SingleAllFolder */
MODE_ALL_FILES_REPEAT /* CycleAllFolder */
},
{
/* | Random | Scan   |Repeat
 * | ON OFF | ON OFF |
 *      OFF   ON             */MODE_FOLDER_SCAN, /* SingleFolder */
MODE_FOLDER_REPEAT_SCAN, /* CycleFolder */
MODE_ONE_FILE_REPEAT, /* SingleFile */
MODE_ALL_FILES_SCAN, /* SingleAllFolder */
MODE_ALL_FILES_REPEAT_SCAN /* CycleAllFolder */
} },
{
{
/* | Random | Scan   |Repeat
 * | ON OFF | ON OFF |
 *      ON       OFF         */MODE_FOLDER_RANDOM, /* SingleFolder */
MODE_FOLDER_RANDOM_REPEAT, /* CycleFolder */
MODE_ONE_FILE_REPEAT, /* SingleFile */
MODE_ALL_FILES_RANDOM, /* SingleAllFolder */
MODE_ALL_FILES_RANDOM_REPEAT /* CycleAllFolder */
},
{
/* | Random | Scan   |Repeat
 * | ON OFF | ON OFF |
 *      ON    ON             */MODE_FOLDER_RANDOM_SCAN, /* SingleFolder */
MODE_FOLDER_RANDOM_REPEAT_SCAN, /* CycleFolder */
MODE_ONE_FILE_REPEAT, /* SingleFile */
MODE_ALL_FILES_RANDOM_SCAN, /* SingleAllFolder */
MODE_ALL_FILES_RANDOM_REPEAT_SCAN /* CycleAllFolder */
} } };
/* *** Command transmission related variable definition end *** */

/* *** Messages definition between host-AE1, display-AE1 task start *** */
/* === Messages: host -> AE1 === */
t_MsgHostToAE1 TMsgHostToAE1;
/* === Messages: display -> AE1 === */
/* === MessageA: AE1 -> display === */
t_AE1MsgForDisplay AE1MsgForDisplay;
/* *** Messages definition between host-AE1, display-AE1 task end *** */

/* *** Save Resume/Current playback information start *** */
/* Media resume information */
resumeMediaInfo_type resumeMediaInfo;
/* Current play information */
static currentPlayInfo_type currentPlayInfo =
{
/* Current folder related */
(U16) 0x0000,/* Folder number which current file is contained to */
(U16) 0x0000,/* Total file number in current folder */
(U16) 0x0000,/* First file number in current folder */
(U16) 0x0000,/* Current file position in current folder */
{ UNKOWN_CODE, (U8) 0x00,
{ (U8) 0x00, } },/* File name information */

/* Resume information */
/* Media information */
{ (U16) 0x0000,/* Total folder number */
(U16) 0x0000,/* Total file number */
(U32) 0x0000,/* VoumeID */
{ (U8) 0x00, (U8) 0x00, (U8) 0x00, (U8) 0x00, (U8) 0x00, (U8) 0x00, (U8) 0x00,
		(U8) 0x00 },/* File size */

/* File related */
(U16) 0x0000,/* Current file number */
{ (U16) 0x0000, (U8) 0x00, (U8) 0x00 },/* Current playback/pause time information */

/* Resume info related[reserved] */
{ (U8) 0x00, (U8) 0x00, (U8) 0x00, (U8) 0x00, (U8) 0x00 },/* Resume information */

/* Media related */
(U8) USB, /* Device information */
{
{ (U16) 0x00 },
{ (U16) 0x00 },
{ (U16) 0x00 } }/* Media information */
} };
/* *** Save Resume/Current playback information end *** */

/* *** Save current media information start *** */
/* Media list supported table */
static U8 mediaListTable[MEDIA_NUMBERS] =
{ MEDIA_TYPE_USB,
#ifdef SD_USED
		MEDIA_TYPE_SD
#endif
		};

/* Current media status information definition */
static mediaStatus_type currentMediaStatus =
{
/* USB media */
{ DISCONNECTED, /* Connection */
FALSE,/* File is invalid */
(U16) 0x0000,/* TotalFileNum */
(U16) 0x0000,/* TotalFolderNum */
(U32) 0x00,/* volumeID */
{ (U8) 0x00, }/* fileSize */
},
#ifdef SD_USED
/* SD media */
{ DISCONNECTED, /* Connection */
FALSE,/* File is invalid */
(U16) 0x0000,/* TotalFileNum */
(U16) 0x0000, /* TotalFolderNum */
(U32) 0x00,/* volumeID */
{ (U8) 0x00, }/* fileSize */
},
#endif
/* Other media */
};
/* *** Save current media information start *** */


static void StartCounter(U32* guardCounter);

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Generate new counter
 * Include           : none
 * Declaration       : static U8 NewCounter(void)
 * Description       : Generate new counter.
 *                   : Command counter increments for each command issued from the host
 * Argument          : none
 * Return Value      : counter value.
 * Calling Functions : none
 *****************************************************************************/
static U8 NewCounter(void)
{
	U8gcmdCounter++;

	U8gcmdCounter &= (U8) 0x7F;
	return U8gcmdCounter;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : send command (Playback/Pause)
 * Include           : none
 * Declaration       : static void sendCmd_PlaybackPause(U8 vPlaybackRequest,
 *                   : 		const cmdPlayback_Pause_type *pplayPara)
 * Description       : send command (Playback/Pause)
 *                   : NOTE,COMMAND CAN ONLY BE SENT EXCEPT BEING TRANSMITTED.
 * Argument          : vPlaybackRequest, playback request code
 *                   : *pplayPara, pointer to playback parameters buffer.
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void sendCmd_PlaybackPause(U8 vPlaybackRequest,
		const cmdPlayback_Pause_type *pplayPara)
{
	/* CDB[0]: Counter */
	U8AE1ComTxBuf[0] = NewCounter();

	/* CDB[1]: ID */
	U8AE1ComTxBuf[1] = CMD_PLAYBACK_PAUSE;

	/* CDB[2]: Link */
	U8AE1ComTxBuf[2] = (U8) 0x00;

	/* CDB[3]&[4]: Parameter size */
	U8AE1ComTxBuf[3] = (U8) 0x00;
	U8AE1ComTxBuf[4] = (U8) 0x0C;

	/* CDB[5]&[6]: Frame size */
	U8AE1ComTxBuf[5] = (U8) 0x00;
	U8AE1ComTxBuf[6] = (U8) 0x14;

	/* CDB[7]: Play require */
	U8AE1ComTxBuf[7] = vPlaybackRequest;

	/* CDB[8]&[9]: Specified file or folder number */
	U8AE1ComTxBuf[8] = (U8) (pplayPara->specifiedFileOrFolderNum >> 8);
	U8AE1ComTxBuf[9]
			= (U8) (pplayPara->specifiedFileOrFolderNum & (U16) 0x00ff);

	/* CDB[10]&[11]: Specified playback time, hour */
	U8AE1ComTxBuf[10] = (U8) (pplayPara->specifiedPlaybackPos_Hour >> 8);
	U8AE1ComTxBuf[11] = (U8) (pplayPara->specifiedPlaybackPos_Hour
			& (U16) 0x00ff);

	/* CDB[12]: Specified playback time, minute */
	U8AE1ComTxBuf[12] = pplayPara->specifiedPlaybackPos_Minute;

	/* CDB[13]: Specified playback time, second */
	U8AE1ComTxBuf[13] = pplayPara->specifiedPlaybackPos_Second;

	/* CDB[14]~[18]: resume information */
	U8AE1ComTxBuf[14] = pplayPara->resumInfo[0];
	U8AE1ComTxBuf[15] = pplayPara->resumInfo[1];
	U8AE1ComTxBuf[16] = pplayPara->resumInfo[2];
	U8AE1ComTxBuf[17] = pplayPara->resumInfo[3];
	U8AE1ComTxBuf[18] = pplayPara->resumInfo[4];

	/* CDB[19]: Checksum */
	U8AE1ComTxBuf[19] = CheckSum8(&U8AE1ComTxBuf[0],
			(U16) ReadU16FromBuf(&U8AE1ComTxBuf[5]) - (U16) 1);

	/* Set flag for start transmission */
	Bgcsi0BeginTX = TRUE;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : send command (folder information)
 * Include           : none
 * Declaration       : static void sendCmd_FolderInfo(const cmdGetFolderInfo_type* cmdGetFolderInfo)
 * Description       : send command (folder information)
 *                   : NOTE,COMMAND CAN ONLY BE SENT EXCEPT BEING TRANSMITTED.
 * Argument          : * pcmdGetFolderInfo, pointer to command parameters buffer
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void sendCmd_FolderInfo(const cmdGetFolderInfo_type* pcmdGetFolderInfo)
{
	/* CDB[0]: Counter */
	U8AE1ComTxBuf[0] = NewCounter();

	/* CDB[1]: ID */
	U8AE1ComTxBuf[1] = CMD_FOLDER_STRUCT;

	/* CDB[2]: Link */
	U8AE1ComTxBuf[2] = (U8) 0x00;

	/* CDB[3]&[4]: Parameter size */
	U8AE1ComTxBuf[3] = (U8) 0x00;
	U8AE1ComTxBuf[4] = (U8) 0x03;

	/* CDB[5]&[6]: Frame size */
	U8AE1ComTxBuf[5] = (U8) 0x00;
	U8AE1ComTxBuf[6] = (U8) 0x0B;

	/* CDB[7]: Standard */
	U8AE1ComTxBuf[7] = pcmdGetFolderInfo->standard;

	/* CDB[8]&[9]: Specified folder number */
	U8AE1ComTxBuf[8] = (U8) (pcmdGetFolderInfo->specifiedFolderNum >> 8);
	U8AE1ComTxBuf[9] = (U8) (pcmdGetFolderInfo->specifiedFolderNum
			& (U16) 0x00ff);

	/* CDB[10]: Checksum */
	U8AE1ComTxBuf[10] = CheckSum8(&U8AE1ComTxBuf[0],
			(U16) ReadU16FromBuf(&U8AE1ComTxBuf[5]) - (U16) 1);

	/* Set flag for start transmission */
	Bgcsi0BeginTX = TRUE;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : send command (Name Information)
 * Include           : none
 * Declaration       : static void sendCmd_NameInfo(const cmdGetNameInfo_type* cmdGetNameInfo)
 * Description       : send command (Name Information)
 *                   : NOTE,COMMAND CAN ONLY BE SENT EXCEPT BEING TRANSMITTED.
 * Argument          : * pcmdGetNameInfo, pointer to command parameters buffer.
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void sendCmd_NameInfo(const cmdGetNameInfo_type* pcmdGetNameInfo)
{
	/* CDB[0]: Counter */
	U8AE1ComTxBuf[0] = NewCounter();

	/* CDB[1]: ID */
	U8AE1ComTxBuf[1] = CMD_NAME_INFO;

	/* CDB[2]: Link */
	U8AE1ComTxBuf[2] = (U8) 0x00;

	/* CDB[3]&[4]: Parameter size */
	U8AE1ComTxBuf[3] = (U8) 0x00;
	U8AE1ComTxBuf[4] = (U8) 0x04;

	/* CDB[5]&[6]: Frame size */
	U8AE1ComTxBuf[5] = (U8) 0x00;
	U8AE1ComTxBuf[6] = (U8) 0x0C;

	/* CDB[7]: Target */
	U8AE1ComTxBuf[7] = pcmdGetNameInfo->target;

	/* CDB[8]: Name type */
	U8AE1ComTxBuf[8] = pcmdGetNameInfo->standard;

	/* CDB[9]: Specified number */
	U8AE1ComTxBuf[9] = (U8) (pcmdGetNameInfo->specifiedNum >> 8);
	U8AE1ComTxBuf[10] = (U8) (pcmdGetNameInfo->specifiedNum & (U16) 0x00ff);

	/* CDB[13]: Checksum */
	U8AE1ComTxBuf[11] = CheckSum8(&U8AE1ComTxBuf[0],
			(U16) ReadU16FromBuf(&U8AE1ComTxBuf[5]) - (U16) 1);

	/* Set flag for start transmission */
	Bgcsi0BeginTX = TRUE;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : send command (Tag Information)
 * Include           : none
 * Declaration       : static void sendCmd_TagInfo(const cmdGetTagInfo_type* pcmdGetTagInfo)
 * Description       : send command (Tag Information)
 *                   : NOTE,COMMAND CAN ONLY BE SENT EXCEPT BEING TRANSMITTED.
 * Argument          : * pcmdGetTagInfo, pointer to command parameters buffer.
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void sendCmd_TagInfo(const cmdGetTagInfo_type* pcmdGetTagInfo)
{
	/* CDB[0]: Counter */
	U8AE1ComTxBuf[0] = NewCounter();

	/* CDB[1]: ID */
	U8AE1ComTxBuf[1] = CMD_TAG_INFO;

	/* CDB[2]: Link */
	U8AE1ComTxBuf[2] = (U8) 0x00;

	/* CDB[3]&[4]: Parameter size */
	U8AE1ComTxBuf[3] = (U8) 0x00;
	U8AE1ComTxBuf[4] = (U8) 0x04;

	/* CDB[5]&[6]: Frame size */
	U8AE1ComTxBuf[5] = (U8) 0x00;
	U8AE1ComTxBuf[6] = (U8) 0x0C;

	/* CDB[7]: Tag type */
	U8AE1ComTxBuf[7] = pcmdGetTagInfo->tagType;

	/* CDB[8]: Target */
	U8AE1ComTxBuf[8] = pcmdGetTagInfo->target;

	/* CDB[9]&[10]: File number */
	U8AE1ComTxBuf[9] = (U8) (pcmdGetTagInfo->fileNum >> 8);
	U8AE1ComTxBuf[10] = (U8) (pcmdGetTagInfo->fileNum & (U16) 0x00ff);

	/* CDB[11]: Checksum */
	U8AE1ComTxBuf[11] = CheckSum8(&U8AE1ComTxBuf[0],
			(U16) ReadU16FromBuf(&U8AE1ComTxBuf[5]) - (U16) 1);

	/* Set flag for start transmission */
	Bgcsi0BeginTX = TRUE;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : send command (Time Information)
 * Include           : none
 * Declaration       : static void sendCmd_TimeInfo(U8 totalOrPlaybakTime)
 * Description       : send command (Time Information)
 *                   : NOTE,COMMAND CAN ONLY BE SENT EXCEPT BEING TRANSMITTED.
 * Argument          : totalOrPlaybakTime, total time or playback time.
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void sendCmd_TimeInfo(U8 totalOrPlaybakTime)
{
	/* CDB[0]: Counter */
	U8AE1ComTxBuf[0] = NewCounter();

	/* CDB[1]: ID */
	U8AE1ComTxBuf[1] = CMD_TIME_INFO;

	/* CDB[2]: Link */
	U8AE1ComTxBuf[2] = (U8) 0x00;

	/* CDB[3]&[4]: Parameter size */
	U8AE1ComTxBuf[3] = (U8) 0x00;
	U8AE1ComTxBuf[4] = (U8) 0x02;

	/* CDB[5]&[6]: Frame size */
	U8AE1ComTxBuf[5] = (U8) 0x00;
	U8AE1ComTxBuf[6] = (U8) 0x0A;

	/* CDB[7]: Reserved */
	U8AE1ComTxBuf[7] = totalOrPlaybakTime;

	/* CDB[8]: Reserved */
	U8AE1ComTxBuf[8] = (U8) 0x00;

	/* CDB[9]: Checksum */
	U8AE1ComTxBuf[9] = CheckSum8(&U8AE1ComTxBuf[0],
			(U16) ReadU16FromBuf(&U8AE1ComTxBuf[5]) - (U16) 1);

	/* Set flag for start transmission */
	Bgcsi0BeginTX = TRUE;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : send command (Media Information Acquisition)
 * Include           : none
 * Declaration       : static void sendCmd_MediaInfoAcq(U8 target)
 * Description       : send command (Media Information Acquisition)
 *                   : NOTE,COMMAND CAN ONLY BE SENT EXCEPT BEING TRANSMITTED.
 * Argument          : target, specified media target.
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void sendCmd_MediaInfoAcq(U8 target)
{
	/* CDB[0]: Counter */
	U8AE1ComTxBuf[0] = NewCounter();

	/* CDB[1]: ID */
	U8AE1ComTxBuf[1] = CMD_MEDIA_INFO_ACQ;

	/* CDB[2]: Link */
	U8AE1ComTxBuf[2] = (U8) 0x00;

	/* CDB[3]&[4]: Parameter size */
	U8AE1ComTxBuf[3] = (U8) 0x00;
	U8AE1ComTxBuf[4] = (U8) 0x01;

	/* CDB[5]&[6]: Frame size */
	U8AE1ComTxBuf[5] = (U8) 0x00;
	U8AE1ComTxBuf[6] = (U8) 0x09;

	/* CDB[7]: Target */
	U8AE1ComTxBuf[7] = target;

	/* CDB[8]: Checksum */
	U8AE1ComTxBuf[8] = CheckSum8(&U8AE1ComTxBuf[0],
			(U16) ReadU16FromBuf(&U8AE1ComTxBuf[5]) - (U16) 1);

	/* Set flag for start transmission */
	Bgcsi0BeginTX = TRUE;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(media information)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_MediaInfo(void)
 * Description       : update media information
 *                   :   connection status
 *                   :   file valid
 *                   :   Total number of folders
 *                   :   Total number of files
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_MediaInfo(void)
{
	/* USB media */
	if (currentMediaStatus.usb.connectSts == CONNECTED)
	{
		/* USB connected */
		AE1MsgForDisplay.usb.connectSts = CONNECTED;
		AE1MsgForDisplay.usb.isFileValid = currentMediaStatus.usb.isFileValid;
		AE1MsgForDisplay.usb.totalFolderNum
				= currentMediaStatus.usb.totalFolderNum;
		AE1MsgForDisplay.usb.totalFileNum = currentMediaStatus.usb.totalFileNum;
	}
	else
	{
		/* USB disconnected */
		AE1MsgForDisplay.usb.connectSts = DISCONNECTED;
		AE1MsgForDisplay.usb.isFileValid = FALSE;
		AE1MsgForDisplay.usb.totalFolderNum = (U16) 0x0000;
		AE1MsgForDisplay.usb.totalFileNum = (U16) 0x0000;
	}
#ifdef SD_USED
	/* SD media */
	if (currentMediaStatus.sd.connectSts == CONNECTED)
	{
		/* SD connected */
		AE1MsgForDisplay.sd.connectSts = CONNECTED;
		AE1MsgForDisplay.sd.isFileValid = currentMediaStatus.sd.isFileValid;
		AE1MsgForDisplay.sd.totalFolderNum
				= currentMediaStatus.sd.totalFolderNum;
		AE1MsgForDisplay.sd.totalFileNum = currentMediaStatus.sd.totalFileNum;
	}
	else
	{
		/* SD disconnected */
		AE1MsgForDisplay.sd.connectSts = DISCONNECTED;
		AE1MsgForDisplay.sd.isFileValid = FALSE;
		AE1MsgForDisplay.sd.totalFolderNum = (U16) 0x0000;
		AE1MsgForDisplay.sd.totalFileNum = (U16) 0x0000;
	}
#endif
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(start playback)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_StartPlay(void)
 * Description       : Start playback
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_StartPlay(void)
{
	AE1MsgForDisplay.currentFile.PlayOrPause = PLAY_STS_PLAYING;
	TPlayState.U8Pause = OFF;

	/* Device which file belongs to */
	AE1MsgForDisplay.currentFile.device
			= (enum_device) currentPlayInfo.resumeInfo.deviceType;

	/* Type */

	/* File-containing folder number */
	AE1MsgForDisplay.currentFile.currentFolderInfo.folderNum
			= currentPlayInfo.currentFolderNum;

	/* File number */
	AE1MsgForDisplay.currentFile.fileNum = currentPlayInfo.resumeInfo.fileNum;

	DispMessage |= (U32) DISP_MSG_PLAYSTATE_CHANGE;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(new file information)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_NewFile(void)
 * Description       : Update message for display(new file information)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_NewFile(void)
{
	/* Type */

	/* File-containing folder number */
	AE1MsgForDisplay.currentFile.currentFolderInfo.folderNum
			= currentPlayInfo.currentFolderNum;

	/* File number */
	AE1MsgForDisplay.currentFile.fileNum = currentPlayInfo.resumeInfo.fileNum;

	/* DispMessage |= (U32)DISP_MSG_FILE_CHANGE */
}


/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(file name)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_FileName(void)
 * Description       : update display(file name)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_FileName(void)
{
	AE1MsgForDisplay.currentFile.fileNameInfo = currentPlayInfo.fileName;

	/* DispMessage |= (U32)DISP_MSG_FILE_CHANGE */
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update specified folder buffer for display(folder name)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_FolderBufFolderName(U8 folderBufIndex)
 * Description       : Update specified folder buffer for display(folder name)
 * Argument          : folderBufIndex, specified folder buffer index
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_FolderBufFolderName(U8 folderBufIndex)
{
	U8 vnameIndex = (U8) 0;
	U8 nameLength = (U8) 0;

	/* Character code */
	switch (pstsGetNameInfo->wordCode)
	{
	case IDB0_UNKOWN_CODE:
		AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[folderBufIndex].folderName.nameCharacterCode
				= UNKOWN_CODE;
		break;
	case IDB0_UTF16_LE:
		AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[folderBufIndex].folderName.nameCharacterCode
				= UTF_16LE;
		break;
	case IDB0_UTF8:
		AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[folderBufIndex].folderName.nameCharacterCode
				= UTF_8;
		break;
	default:
		/* Ignore other value */
		break;
	}

	/* NOTE:
	 * BECAUSE AE1 CAN NOT IDENTIFY THE CORRECT CODE, SO HERE SET AS "UTF-16LE"
	 * IF AE1 BUG IS RESOLVED, THIS LINE SHOULD BE DELETED. */
	//AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[folderBufIndex].folderName.nameCharacterCode
	//		= UTF_16LE;

	/* Folder number */
	AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[folderBufIndex].folderNum
			= ReadU16FromBuf((U8*) &(pstsGetNameInfo->fileOrFolderNum));

	/* Folder name length */
	if (pstsGetNameInfo->length <= FILE_NAME_LENGTH)
	{
		nameLength = pstsGetNameInfo->length;
	}
	else
	{
		nameLength = FILE_NAME_LENGTH;
	}
	AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[folderBufIndex].folderName.nameLength
			= nameLength;

	/* Folder name */
	for (vnameIndex = (U8) 0; vnameIndex < nameLength; vnameIndex++)
	{
		AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[folderBufIndex].folderName.Name[vnameIndex]
				= pstsGetNameInfo->name[vnameIndex];
	}
	/* Name string length end flag */
	AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[folderBufIndex].folderName.Name[nameLength]
			= (U8) 0;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(clear folder buffer information)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_ClearFolderBuf(void)
 * Description       : Update message for display(clear folder buffer information)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_ClearFolderBuf(void)
{
	U8 folderBufIndex = (U8) 0;

	/* Clear folder buffer information */
	for (folderBufIndex = (U8) 0; folderBufIndex < FOLDER_INFO_BUF_DEPTH; folderBufIndex++)
	{
		/* Folder number */
		AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[folderBufIndex].folderNum
				= (U16) 0x0000;
		AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[folderBufIndex].containFileNum
				= (U16) 0x0000;
		AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[folderBufIndex].firstFileNumInFolder
				= (U16) 0x0000;
		/* Character code */
		AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[folderBufIndex].folderName.nameCharacterCode
				= UNKOWN_CODE;
		/* Folder name length */
		AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[folderBufIndex].folderName.nameLength
				= (U8) 0x00;
		/* File name */
		AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[folderBufIndex].folderName.Name[0]
				= (U8) 0x00;
	}
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : normalize variable, folder buffer index
 * Include           : none
 * Declaration       : static U8 normalizeFolderBufIndex(U8 vFolderBufIndex)
 * Description       : normalize variable, folder buffer index
 * Argument          : value should be normalized
 * Return Value      : value normalized
 * Calling Functions : none
 *****************************************************************************/
static U8 normalizeFolderBufIndex(U8 vFolderBufIndex)
{
	return (vFolderBufIndex &= (FOLDER_INFO_BUF_DEPTH - (U8) 1));
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(clear folder buffer information)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_ClearSpecifiedFolderBuf(U16 specifiedFolderBufIndex)
 * Description       : Update message for display(clear folder buffer information)
 * Argument          : specifiedFolderBufIndex, specified folder buffer index.
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_ClearSpecifiedFolderBuf(
		U8 specifiedFolderBufIndex)
{
	/* Clear folder buffer information */
	/* Folder number */
	AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[specifiedFolderBufIndex].folderNum
			= (U16) 0x0000;
	AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[specifiedFolderBufIndex].containFileNum
			= (U16) 0x0000;
	AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[specifiedFolderBufIndex].firstFileNumInFolder
			= (U16) 0x0000;
	/* Character code */
	AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[specifiedFolderBufIndex].folderName.nameCharacterCode
			= UNKOWN_CODE;
	/* Folder name length */
	AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[specifiedFolderBufIndex].folderName.nameLength
			= (U8) 0x00;
	/* File name */
	AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[specifiedFolderBufIndex].folderName.Name[0]
			= (U8) 0x00;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Clear folder buffer as specified start buffer and total buffer count
 * Include           : none
 * Declaration       : static void ClearFolderBuf(U16 startIndex, U16 totalBufCount)
 * Description       : Clear folder buffer as specified start buffer and total buffer count
 * Argument          : startIndex, specified start buffer index which to be cleared
 *                   : totalBufCount, total buffer count.
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void ClearFolderBuf(U16 startIndex, U16 totalBufCount)
{
	U16 folderBufIndex = (U16) 0;

	for (folderBufIndex = (U16) 0; folderBufIndex < totalBufCount; folderBufIndex++)
	{
		UpdateAE1MsgForDisp_ClearSpecifiedFolderBuf(
				normalizeFolderBufIndex(startIndex + folderBufIndex));
	}
}
/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(current folder name)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_CurrentFolderName(void)
 * Description       : update display(current folder name)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_CurrentFolderName(void)
{
	U8 vnameIndex = (U8) 0;
	U8 nameLength = (U8) 0;

	/* Character code */
	switch (pstsGetNameInfo->wordCode)
	{
	case IDB0_UNKOWN_CODE:
		AE1MsgForDisplay.currentFile.currentFolderInfo.folderName.nameCharacterCode
				= UNKOWN_CODE;
		break;
	case IDB0_UTF16_LE:
		AE1MsgForDisplay.currentFile.currentFolderInfo.folderName.nameCharacterCode
				= UTF_16LE;
		break;
	case IDB0_UTF8:
		AE1MsgForDisplay.currentFile.currentFolderInfo.folderName.nameCharacterCode
				= UTF_8;
		break;
	default:
		/* Ignore other value */
		break;
	}

	/* NOTE:
	 * BECAUSE AE1 CAN NOT IDENTIFY THE CORRECT CODE, SO HERE SET AS "UTF-16LE"
	 * IF AE1 BUG IS RESOLVED, THIS LINE SHOULD BE DELETED. */
	//AE1MsgForDisplay.currentFile.currentFolderInfo.folderName.nameCharacterCode
	//		= UTF_16LE;

	/* Folder number */
	AE1MsgForDisplay.currentFile.currentFolderInfo.folderNum = ReadU16FromBuf(
			(U8*) &(pstsGetNameInfo->fileOrFolderNum));

	/* Folder name length */
	if (pstsGetNameInfo->length <= FILE_NAME_LENGTH)
	{
		nameLength = pstsGetNameInfo->length;
	}
	else
	{
		nameLength = FILE_NAME_LENGTH;
	}
	AE1MsgForDisplay.currentFile.currentFolderInfo.folderName.nameLength
			= nameLength;

	/* Folder name */
	for (vnameIndex = (U8) 0; vnameIndex < nameLength; vnameIndex++)
	{
		AE1MsgForDisplay.currentFile.currentFolderInfo.folderName.Name[vnameIndex]
				= pstsGetNameInfo->name[vnameIndex];
	}
	/* Name string length end flag */
	AE1MsgForDisplay.currentFile.currentFolderInfo.folderName.Name[nameLength]
			= (U8) 0;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(clear current folder name)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_ClearCurrentFolderInfo(void)
 * Description       : update display(clear current folder name)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_ClearCurrentFolderInfo(void)
{
	/* Clear next folder number & contained file number information */
	AE1MsgForDisplay.currentFile.currentFolderInfo.folderNum = (U16) 0x0000;
	AE1MsgForDisplay.currentFile.currentFolderInfo.containFileNum
			= (U16) 0x0000;

	/* Character code */
	AE1MsgForDisplay.currentFile.currentFolderInfo.folderName.nameCharacterCode
			= UNKOWN_CODE;

	/* Folder number */
	AE1MsgForDisplay.currentFile.currentFolderInfo.folderNum = (U16) 0x0000;

	/* Folder name length */
	AE1MsgForDisplay.currentFile.currentFolderInfo.folderName.nameLength
			= (U8) 0x00;

	/* File name */
	AE1MsgForDisplay.currentFile.currentFolderInfo.folderName.Name[0] = (U8) 0;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(tag information-title, version & code)
 * Include           : none
 * Declaration       : static void SetTagVersionAndCode_title(void)
 * Description       : update display(tag information-title)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void SetTagVersionAndCode_title(void)
{
	/* Version */
	switch (pstsGetTagInfo->version)
	{
	case IDB1_VER_ID3V22:
		AE1MsgForDisplay.currentFile.tagInfo.title.version = ID3V22;
		break;
	case IDB1_VER_ID3V23:
		AE1MsgForDisplay.currentFile.tagInfo.title.version = ID3V23;
		break;
	case IDB1_VER_ID3V24:
		AE1MsgForDisplay.currentFile.tagInfo.title.version = ID3V24;
		break;
	case IDB1_VER_ID3V10:
		AE1MsgForDisplay.currentFile.tagInfo.title.version = ID3V10;
		break;
	case IDB1_VER_ID3V11:
		AE1MsgForDisplay.currentFile.tagInfo.title.version = ID3V11;
		break;
	case IDB1_VER_WMA:
		AE1MsgForDisplay.currentFile.tagInfo.title.version = WMACONTENTS;
		break;
	case IDB1_VER_MP4:
		AE1MsgForDisplay.currentFile.tagInfo.title.version = MP4CONTENTS;
		break;
	case IDB1_VER_WAV:
		AE1MsgForDisplay.currentFile.tagInfo.title.version = WMACONTENTS;
		break;
	default:
		/* Other version word */
		break;
	}

	/* Character code */
	switch (pstsGetTagInfo->wordCode)
	{
	case IDB1_CHAR_CODE_UNKOWN:
		AE1MsgForDisplay.currentFile.tagInfo.title.characterCode = UNKOWN;
		break;
	case IDB1_CHAR_CODE_UTF16_LE:
		AE1MsgForDisplay.currentFile.tagInfo.title.characterCode
				= UNICODE_UTF16_LE;
		break;
	case IDB1_CHAR_CODE_UTF16_BE:
		AE1MsgForDisplay.currentFile.tagInfo.title.characterCode
				= UNICODE_UTF16_BE;
		break;
	case IDB1_CHAR_CODE_UTF8:
		AE1MsgForDisplay.currentFile.tagInfo.title.characterCode = UNICODE_UTF8;
		break;
	case IDB1_CHAR_CODE_UTF16_WITH_BOM:
		AE1MsgForDisplay.currentFile.tagInfo.title.characterCode
				= UNICODE_UTF16_WITH_BOM;
		break;
	case IDB1_CHAR_CODE_ISO8859:
		AE1MsgForDisplay.currentFile.tagInfo.title.characterCode = ISO8859;
		break;
	case IDB1_CHAR_CODE_EXCEPTION:
		AE1MsgForDisplay.currentFile.tagInfo.title.characterCode = EXCEPTION;
		break;
	default:
		/* To do: process other value words if necessary */
		break;
	}
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(no tag information-title)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_TagInfoTitle(void)
 * Description       : update display(no tag information-title)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_NoTagInfoTitle(void)
{
	/* Set tag version and code */
	SetTagVersionAndCode_title();

	/* Length */
	AE1MsgForDisplay.currentFile.tagInfo.title.length = (U8) 0;

	/* Name */
	AE1MsgForDisplay.currentFile.tagInfo.title.name[0] = (U8) 0;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(tag information-artist, version & code)
 * Include           : none
 * Declaration       : static void SetTagVersionAndCode_artist(void)
 * Description       : update display(tag information-title)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void SetTagVersionAndCode_artist(void)
{
	/* Version */
	switch (pstsGetTagInfo->version)
	{
	case IDB1_VER_ID3V22:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.version = ID3V22;
		break;
	case IDB1_VER_ID3V23:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.version = ID3V23;
		break;
	case IDB1_VER_ID3V24:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.version = ID3V24;
		break;
	case IDB1_VER_ID3V10:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.version = ID3V10;
		break;
	case IDB1_VER_ID3V11:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.version = ID3V11;
		break;
	case IDB1_VER_WMA:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.version = WMACONTENTS;
		break;
	case IDB1_VER_MP4:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.version = MP4CONTENTS;
		break;
	case IDB1_VER_WAV:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.version = WMACONTENTS;
		break;
	default:
		/* Other version word */
		break;
	}

	/* Character code */
	switch (pstsGetTagInfo->wordCode)
	{
	case IDB1_CHAR_CODE_UNKOWN:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.characterCode = UNKOWN;
		break;
	case IDB1_CHAR_CODE_UTF16_LE:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.characterCode
				= UNICODE_UTF16_LE;
		break;
	case IDB1_CHAR_CODE_UTF16_BE:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.characterCode
				= UNICODE_UTF16_BE;
		break;
	case IDB1_CHAR_CODE_UTF8:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.characterCode
				= UNICODE_UTF8;
		break;
	case IDB1_CHAR_CODE_UTF16_WITH_BOM:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.characterCode
				= UNICODE_UTF16_WITH_BOM;
		break;
	case IDB1_CHAR_CODE_ISO8859:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.characterCode = ISO8859;
		break;
	case IDB1_CHAR_CODE_EXCEPTION:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.characterCode
				= EXCEPTION;
		break;
	default:
		/* To do: process other value words if necessary */
		break;
	}
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(no tag information-artist)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_NoTagInfoArtist(void)
 * Description       : update display(no tag information-artist)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_NoTagInfoArtist(void)
{
	/* Version & code */
	SetTagVersionAndCode_artist();

	/* Length */
	AE1MsgForDisplay.currentFile.tagInfo.artistName.length = (U8) 0;

	/* Name */
	AE1MsgForDisplay.currentFile.tagInfo.artistName.name[0] = (U8) 0;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(tag information-album, version & code)
 * Include           : none
 * Declaration       : static void SetTagVersionAndCode_album(void)
 * Description       : update display(tag information-title)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void SetTagVersionAndCode_album(void)
{
	/* Version */
	switch (pstsGetTagInfo->version)
	{
	case IDB1_VER_ID3V22:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.version = ID3V22;
		break;
	case IDB1_VER_ID3V23:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.version = ID3V23;
		break;
	case IDB1_VER_ID3V24:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.version = ID3V24;
		break;
	case IDB1_VER_ID3V10:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.version = ID3V10;
		break;
	case IDB1_VER_ID3V11:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.version = ID3V11;
		break;
	case IDB1_VER_WMA:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.version = WMACONTENTS;
		break;
	case IDB1_VER_MP4:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.version = MP4CONTENTS;
		break;
	case IDB1_VER_WAV:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.version = WMACONTENTS;
		break;
	default:
		/* Other version word */
		break;
	}

	/* Character code */
	switch (pstsGetTagInfo->wordCode)
	{
	case IDB1_CHAR_CODE_UNKOWN:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.characterCode = UNKOWN;
		break;
	case IDB1_CHAR_CODE_UTF16_LE:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.characterCode
				= UNICODE_UTF16_LE;
		break;
	case IDB1_CHAR_CODE_UTF16_BE:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.characterCode
				= UNICODE_UTF16_BE;
		break;
	case IDB1_CHAR_CODE_UTF8:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.characterCode
				= UNICODE_UTF8;
		break;
	case IDB1_CHAR_CODE_UTF16_WITH_BOM:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.characterCode
				= UNICODE_UTF16_WITH_BOM;
		break;
	case IDB1_CHAR_CODE_ISO8859:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.characterCode = ISO8859;
		break;
	case IDB1_CHAR_CODE_EXCEPTION:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.characterCode
				= EXCEPTION;
		break;
	default:
		/* To do: process other value words if necessary */
		break;
	}
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(no tag information-album)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_NoTagInfoAlbum(void)
 * Description       : update display(no tag information-album)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_NoTagInfoAlbum(void)
{
	/* Version & code */
	SetTagVersionAndCode_album();

	/* Length */
	AE1MsgForDisplay.currentFile.tagInfo.AlbumName.length = (U8) 0;

	/* Name */
	AE1MsgForDisplay.currentFile.tagInfo.AlbumName.name[0] = (U8) 0;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(tag information-title)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_TagInfo_Title(void)
 * Description       : update display(tag information-title)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_TagInfo_Title(void)
{
	U8 vnameIndex = (U8) 0;
	U8 tagLength = (U8) 0;

	/* Set tag version and code */
	SetTagVersionAndCode_title();

	/* Length */
	if (pstsGetTagInfo->length <= TAG_LENGTH)
	{
		tagLength = pstsGetTagInfo->length;
	}
	else
	{
		tagLength = TAG_LENGTH;
	}
	AE1MsgForDisplay.currentFile.tagInfo.title.length = tagLength;

	/* Name */
	for (vnameIndex = (U8) 0; vnameIndex < tagLength; vnameIndex++)
	{
		AE1MsgForDisplay.currentFile.tagInfo.title.name[vnameIndex]
			= pstsGetTagInfo->name[vnameIndex];
	}
	/* Name string end flag */
	AE1MsgForDisplay.currentFile.tagInfo.title.name[tagLength] = (U8) 0;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(tag information-album)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_TagInfo_Album(void)
 * Description       : update display(tag information-album)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_TagInfo_Album(void)
{
	U8 vnameIndex = (U8) 0;
	U8 tagLength = (U8) 0;

	/* Version & code */
	SetTagVersionAndCode_album();

	/* Length */
	if (pstsGetTagInfo->length <= TAG_LENGTH)
	{
		tagLength = pstsGetTagInfo->length;
	}
	else
	{
		tagLength = TAG_LENGTH;
	}
	AE1MsgForDisplay.currentFile.tagInfo.AlbumName.length
			= tagLength;

	/* Name */
	for (vnameIndex = (U8) 0; vnameIndex < tagLength; vnameIndex++)
	{
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.name[vnameIndex]
				= pstsGetTagInfo->name[vnameIndex];
	}
	/* Name string end flag */
	AE1MsgForDisplay.currentFile.tagInfo.AlbumName.name[tagLength] = (U8) 0;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(tag information-artist)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_TagInfo_artist(void)
 * Description       : update display(tag information-artist)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_TagInfo_Artist(void)
{
	U8 vnameIndex = (U8) 0;
	U8 tagLength = (U8) 0;

	/* Version & code */
	SetTagVersionAndCode_artist();

	/* Length */
	if (pstsGetTagInfo->length <= TAG_LENGTH)
	{
		tagLength = pstsGetTagInfo->length;
	}
	else
	{
		tagLength = TAG_LENGTH;
	}
	AE1MsgForDisplay.currentFile.tagInfo.artistName.length
			= tagLength;

	/* Name */
	for (vnameIndex = (U8) 0; vnameIndex < tagLength; vnameIndex++)
	{
		AE1MsgForDisplay.currentFile.tagInfo.artistName.name[vnameIndex]
				= pstsGetTagInfo->name[vnameIndex];
	}
	/* Name string end flag */
	AE1MsgForDisplay.currentFile.tagInfo.artistName.name[tagLength] = (U8) 0;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(total time)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_TotalTime(void)
 * Description       : update display(total time)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_TotalTime(void)
{
	U32 vtimeInSecond = (U32) 0;

	vtimeInSecond = (U32) ReadU16FromBuf((U8*) &(pstsTimeInfo->hour));/* Hour */
	vtimeInSecond = vtimeInSecond * (U32) 60;

	vtimeInSecond = vtimeInSecond + pstsTimeInfo->minute;/* Minute */
	vtimeInSecond = vtimeInSecond * (U32) 60;/* Second */

	vtimeInSecond = vtimeInSecond + pstsTimeInfo->second;/* Second */

	AE1MsgForDisplay.currentFile.totalPlaybackTimeInSecond = vtimeInSecond;

	DispMessage |= (U32) DISP_MSG_PLAYTIMER_CHANGE;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(playback time when resume)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_ResumePlaytime(void)
 * Description       : update display(playback time when resume)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_ResumePlaytime(void)
{
	U32 timeInSecond = (U32) 0;

	timeInSecond = currentPlayInfo.resumeInfo.timeInfo.hour;
	timeInSecond = timeInSecond * (U32) 60;/* Minute */

	timeInSecond = timeInSecond + currentPlayInfo.resumeInfo.timeInfo.minute;/* Minute */

	timeInSecond = timeInSecond * (U32) 60;/* Second */

	timeInSecond = timeInSecond + currentPlayInfo.resumeInfo.timeInfo.second;/* Second */

	AE1MsgForDisplay.currentFile.PlaybackTimeInSecond = timeInSecond;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(Clear playback time)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_ClearPlaytime(void)
 * Description       : update display(clear playback time)
 *                   :
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_ClearPlaytime(void)
{
	AE1MsgForDisplay.currentFile.PlaybackTimeInSecond = (U32) 0x0000;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(USB disconnected)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_UsbDisconnected(void)
 * Description       : Update message for display(USB disconnected)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_UsbDisconnected(void)
{
	/*** USB connection status ***/
	AE1MsgForDisplay.usb.connectSts = currentMediaStatus.usb.connectSts;
	AE1MsgForDisplay.usb.isFileValid = currentMediaStatus.usb.isFileValid;
	AE1MsgForDisplay.usb.totalFileNum = currentMediaStatus.usb.totalFileNum;
	AE1MsgForDisplay.usb.totalFolderNum = currentMediaStatus.usb.totalFolderNum;
	/* Message for display */
	DispMessage |= (U32) DISP_MSG_DISK_CHANGE;

	/*** Playback mode: ignored ***/

	/*** Current file information ***/
	/* InfoUpdate: ignored */
	/* Device */
	/* PreviousFolderInfo */
	/* CurrentFolderInfo */
	/* NextFolderInfo */
	/* FileNameInfo */
	/* File-containing folder number */
	/* FileNumInCurrentFolder */
	/* File number */
	/* PlaybackTimeInSecond */
	/* TotalPlaybackTimeInSecond */
	/* TtagInfo */
	/* PlayOrPause */

	/*** AE1 version: ignored ***/
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Inform display that USB media connection detected
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_UsbConnected(void)
 * Description       : Inform display that USB media connection detected
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_UsbConnected(void)
{
	AE1MsgForDisplay.usb.connectSts = CONNECTED;
	/* Update display information */
	DispMessage |= (U32) DISP_MSG_DISK_CHANGE;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(SD disconnected)
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_SdDisconnected(void)
 * Description       : Update message for display(SD disconnected)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
#ifdef SD_USED
static void UpdateAE1MsgForDisp_SdDisconnected(void)
{
	/*** SD connection status ***/
	AE1MsgForDisplay.sd.connectSts = currentMediaStatus.sd.connectSts;
	AE1MsgForDisplay.sd.isFileValid = currentMediaStatus.sd.isFileValid;
	AE1MsgForDisplay.sd.totalFileNum = currentMediaStatus.sd.totalFileNum;
	AE1MsgForDisplay.sd.totalFolderNum = currentMediaStatus.sd.totalFolderNum;
	/* Message for display */
	DispMessage |= (U32) DISP_MSG_DISK_CHANGE;

	/*** Playback mode: ignored ***/

	/*** Current file information ***/
	/* InfoUpdate: ignored */
	/* Device */
	/* PreviousFolderInfo */
	/* CcurrentFolderInfo */
	/* NextFolderInfo */
	/* FfileNameInfo */
	/* File-containing folder number */
	/* FileNumInCurrentFolder */
	/* File number */
	/* PlaybackTimeInSecond */
	/* TotalPlaybackTimeInSecond */
	/* TagInfo */
	/* PlayOrPause */

	/*** AE1 version: ignored ***/
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Inform display that SD media connection detected
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_SdConnected(void)
 * Description       : Inform display that SD media connection detected
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_SdConnected(void)
{
	AE1MsgForDisplay.sd.connectSts = CONNECTED;
	/* Update display information */
	DispMessage |= (U32) DISP_MSG_DISK_CHANGE;
}
#endif

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Inform display that Clear current file information
 * Include           : none
 * Declaration       : static void UpdateAE1MsgForDisp_ClearCurrentFile(void)
 * Description       : Inform display that Clear current file information
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UpdateAE1MsgForDisp_ClearCurrentFile(void)
{
	/*** Current file information ***/
	/* InfoUpdate: ignored */
	/* Device */
	AE1MsgForDisplay.currentFile.device = INVALID;
	/* Clear folder Info except current folder information */
	UpdateAE1MsgForDisp_ClearFolderBuf();
	/* CurrentFolderInfo */
	UpdateAE1MsgForDisp_ClearCurrentFolderInfo();
	DispMessage |= (U32) DISP_MSG_FOLDER_CHANGE;
	/* FileNameInfo */
	AE1MsgForDisplay.currentFile.fileNameInfo.nameLength = (U8) 0x00;
	AE1MsgForDisplay.currentFile.fileNameInfo.nameCharacterCode = UNKOWN_CODE;
	AE1MsgForDisplay.currentFile.fileNameInfo.Name[0] = (U8) 0x00;
	/* File-containing folder number */
	AE1MsgForDisplay.currentFile.currentFolderInfo.folderNum = (U16) 0x0000;
	/* FileNumInCurrentFolder */
	AE1MsgForDisplay.currentFile.fileNumInCurrentFolder = (U16) 0x0000;
	/* File number */
	AE1MsgForDisplay.currentFile.fileNum = (U16) 0x0000;
	/* PlaybackTimeInSecond */
	AE1MsgForDisplay.currentFile.PlaybackTimeInSecond = (U32) 0x0000;
	/* TotalPlaybackTimeInSecond */
	AE1MsgForDisplay.currentFile.totalPlaybackTimeInSecond = (U32) 0x0000;
	DispMessage |= (U32) DISP_MSG_PLAYTIMER_CHANGE;
	/* TagInfo */
	UpdateAE1MsgForDisp_NoTagInfoTitle();
	UpdateAE1MsgForDisp_NoTagInfoArtist();
	UpdateAE1MsgForDisp_NoTagInfoAlbum();
	DispMessage |= (U32) DISP_MSG_FILE_CHANGE;
	/* PlayOrPause */
	AE1MsgForDisplay.currentFile.PlayOrPause = PLAY_STS_PAUSE;
	TPlayState.U8Pause = ON;
	DispMessage |= (U32) DISP_MSG_PLAYSTATE_CHANGE;
	AE1MsgForDisplay.currentFile.InfoUpdate = TRUE;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Clear spontaneous STS(ID = 83H, Connection Status)
 * Include           : none
 * Declaration       : Clear void ClearSponSTS_Connect(void)
 * Description       : Clear spontaneous STS(ID = 83H, Connection Status)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void ClearSponSTS_Connect(void)
{
	stsConnectStatus.overCurrent = (U8) 0xFF;
	stsConnectStatus.usbConnectInfo = (U8) 0xFF;
	stsConnectStatus.connectPortNum = (U8) 0xFF;
	stsConnectStatus.usbConnectPort = (U8) 0xFF;
	stsConnectStatus.sdConnectInfo = (U8) 0xFF;
	stsConnectStatus.maxLunNum = (U8) 0x00;
	stsConnectStatus.connectLunNum = (U16) 0x0000;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Save spontaneous STS(ID = 83H, Connection Status)
 * Include           : none
 * Declaration       : static void SaveSponSTS_Connect(void)
 * Description       : Save spontaneous STS(ID = 83H, Connection Status)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void SaveSponSTS_Connect(void)
{
	stsConnectStatus.overCurrent = pstsConnectStatus->overCurrent;
	stsConnectStatus.usbConnectInfo = pstsConnectStatus->usbConnectInfo;
	stsConnectStatus.connectPortNum = pstsConnectStatus->connectPortNum;
	stsConnectStatus.usbConnectPort = pstsConnectStatus->usbConnectPort;
	stsConnectStatus.sdConnectInfo = pstsConnectStatus->sdConnectInfo;
	stsConnectStatus.maxLunNum = pstsConnectStatus->maxLunNum;
	stsConnectStatus.connectLunNum = ReadU16FromBuf(
			(U8*) &(pstsConnectStatus->connectLunNum));
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Clear spontaneous STS(ID = 90H, Playback/Pause Status)
 * Include           : none
 * Declaration       : static void ClearSponSTS_PlaybackPause(void)
 * Description       : Clear spontaneous STS(ID = 90H, Playback/Pause Status)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void ClearSponSTS_PlaybackPause(void)
{
	stsPlayback_Pause.playStatus = (U8) 0xFF;
	stsPlayback_Pause.musicType = (U8) 0xFF;
	stsPlayback_Pause.subjectFolderNum = (U16) 0x0000;
	stsPlayback_Pause.fileNum = (U16) 0x0000;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Save spontaneous STS(ID = 90H, Playback/Pause Status)
 * Include           : none
 * Declaration       : static void SaveSponSTS_PlaybackPause(void)
 * Description       : Save spontaneous STS(ID = 90H, Playback/Pause Status)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void SaveSponSTS_PlaybackPause(void)
{
	stsPlayback_Pause.playStatus = pstsPlayback_Pause->playStatus;
	stsPlayback_Pause.musicType = pstsPlayback_Pause->musicType;
	stsPlayback_Pause.subjectFolderNum = ReadU16FromBuf(
			(U8*) &(pstsPlayback_Pause->subjectFolderNum));
	stsPlayback_Pause.fileNum = ReadU16FromBuf(
			(U8*) &(pstsPlayback_Pause->fileNum));
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Clear spontaneous STS(ID = B3H, Time information)
 * Include           : none
 * Declaration       : static void ClearSponSTS_TimeInfo(void)
 * Description       : Clear spontaneous STS(ID = B3H, Time information)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void ClearSponSTS_TimeInfo(void)
{
	stsTimeInfo.statusType = (U8) 0x00;
	stsTimeInfo.getResult = (U8) 0x80;
	stsTimeInfo.playStatus = (U8) 0x00;
	stsTimeInfo.hour = (U16) 0x0000;
	stsTimeInfo.minute = (U8) 0x00;
	stsTimeInfo.second = (U8) 0x00;
	stsTimeInfo.resumeInfo[0] = (U8) 0x00;
	stsTimeInfo.resumeInfo[1] = (U8) 0x00;
	stsTimeInfo.resumeInfo[2] = (U8) 0x00;
	stsTimeInfo.resumeInfo[3] = (U8) 0x00;
	stsTimeInfo.resumeInfo[4] = (U8) 0x00;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Save spontaneous STS(ID = B3H, Time information)
 * Include           : none
 * Declaration       : static void SaveSponSTS_TimeInfo(void)
 * Description       : Save spontaneous STS(ID = B3H, Time information)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void SaveSponSTS_TimeInfo(void)
{
	U8 resumeIndex = (U8) 0;
	U8 maxResumInfoNum = (U8) 5;

	stsTimeInfo.statusType = pstsTimeInfo->statusType;
	stsTimeInfo.getResult = pstsTimeInfo->getResult;
	stsTimeInfo.playStatus = pstsTimeInfo->playStatus;
	stsTimeInfo.hour = ReadU16FromBuf((U8*) &(pstsTimeInfo->hour));
	stsTimeInfo.minute = pstsTimeInfo->minute;
	stsTimeInfo.second = pstsTimeInfo->second;
	for (resumeIndex = (U8) 0; resumeIndex < maxResumInfoNum; resumeIndex++)
	{
		stsTimeInfo.resumeInfo[resumeIndex]
				= pstsTimeInfo->resumeInfo[resumeIndex];
	}
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Save media information for resume judgment
 * Include           : none
 * Declaration       : static void SaveTempMediaInfo(U8 target)
 * Description       : Save media information for resume judgment
 *                   : vendor ID & Word information
 *                   : Product ID & Word information
 *                   : Serial ID & Word information
 * Argument          : target, target to be saved
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void SaveTempMediaInfo(U8 target)
{
#ifdef SAVE_MORE_MEDIA_INFO
	U8 wordIndex = (U8)0;
#endif

	switch (target)
	{
	case TARGET_USB_VENDOR_INFO:
#ifdef SD_USED
	case TARGET_SD_VENDOR_INFO:
#endif
		/* Save USB & SD vendor information */
		tempMediaInfo.vendor.id = ReadU16FromBuf((U8*) &(pstsMediaInfo->id));
#ifdef SAVE_MORE_MEDIA_INFO
		tempMediaInfo.vendor.length = pstsMediaInfo->length;
		for(wordIndex = (U8)0;wordIndex < pstsMediaInfo->length;wordIndex ++)
		{
			tempMediaInfo.vendor.word[wordIndex] = pstsMediaInfo->name[wordIndex];
		}
#endif
		break;
	case TARGET_USB_PRODUCT_INFO:
#ifdef SD_USED
	case TARGET_SD_PRODUCT_INFO:
#endif
		/* Save USB & SD Product information */
		tempMediaInfo.product.id = ReadU16FromBuf((U8*) &(pstsMediaInfo->id));
#ifdef SAVE_MORE_MEDIA_INFO
		tempMediaInfo.product.length = pstsMediaInfo->length;
		for(wordIndex = (U8)0;wordIndex < pstsMediaInfo->length;wordIndex ++)
		{
			tempMediaInfo.product.word[wordIndex] = pstsMediaInfo->name[wordIndex];
		}
#endif
		break;
	case TARGET_USB_SERIAL_NUM:
#ifdef SD_USED
	case TARGET_SD_SERIAL_NUM:
#endif
		/* Save USB & SD Serial information */
		tempMediaInfo.serial.id = ReadU16FromBuf((U8*) &(pstsMediaInfo->id));
#ifdef SAVE_MORE_MEDIA_INFO
		tempMediaInfo.serial.length = pstsMediaInfo->length;
		for(wordIndex = (U8)0;wordIndex < pstsMediaInfo->length;wordIndex ++)
		{
			tempMediaInfo.serial.word[wordIndex] = pstsMediaInfo->name[wordIndex];
		}
#endif
		break;
	default:
		/* Ignore other message */
		break;
	}
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Save current playback media information
 * Include           : none
 * Declaration       : static void SaveCurrentPlaybackMediaInfo(void)
 * Description       : Save current playback media information
 *                   :   vendor/product/serial information
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void SaveCurrentPlaybackMediaInfo(void)
{
#ifdef SAVE_MORE_MEDIA_INFO
	U8 wordIndex = (U8)0;

	currentPlayInfo.resumeInfo.mediaInfo.vendor.length = tempMediaInfo.vendor.length;
	for(wordIndex = (U8)0;wordIndex < tempMediaInfo.vendor.length; wordIndex++)
	{
		currentPlayInfo.resumeInfo.mediaInfo.vendor.word[wordIndex] = tempMediaInfo.vendor.word[wordIndex];
	}
	currentPlayInfo.resumeInfo.mediaInfo.product.length = tempMediaInfo.product.length;
	for(wordIndex = (U8)0;wordIndex < tempMediaInfo.product.length; wordIndex++)
	{
		currentPlayInfo.resumeInfo.mediaInfo.product.word[wordIndex] = tempMediaInfo.product.word[wordIndex];
	}
	currentPlayInfo.resumeInfo.mediaInfo.serial.length = tempMediaInfo.serial.length;
	for(wordIndex = (U8)0;wordIndex < tempMediaInfo.serial.length; wordIndex++)
	{
		currentPlayInfo.resumeInfo.mediaInfo.serial.word[wordIndex] = tempMediaInfo.serial.word[wordIndex];
	}
#endif

	currentPlayInfo.resumeInfo.mediaInfo.vendor.id = tempMediaInfo.vendor.id;
	currentPlayInfo.resumeInfo.mediaInfo.product.id = tempMediaInfo.product.id;
	currentPlayInfo.resumeInfo.mediaInfo.serial.id = tempMediaInfo.serial.id;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Save current file name information
 * Include           : none
 * Declaration       : static void SaveCurrentFileNameInfo(void)
 * Description       : Save current file name information
 *                   :   character code/length/name[]
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void SaveCurrentFileNameInfo(void)
{
	U8 vnameIndex = (U8) 0;
	U8 nameLength = (U8) 0;

	/* Character code */
	switch (pstsGetNameInfo->wordCode)
	{
	case IDB0_UNKOWN_CODE:
		currentPlayInfo.fileName.nameCharacterCode = UNKOWN_CODE;
		break;
	case IDB0_UTF16_LE:
		currentPlayInfo.fileName.nameCharacterCode = UTF_16LE;
		break;
	case IDB0_UTF8:
		currentPlayInfo.fileName.nameCharacterCode = UTF_8;
		break;
	default:
		/* Ignore other value */
		break;
	}

	/* NOTE:
	 * BECAUSE AE1 CAN NOT IDENTIFY THE CORRECT CODE, SO HERE SET AS "UTF-16LE"
	 * IF AE1 BUG IS RESOLVED, THIS LINE SHOULD BE DELETED. */
	//currentPlayInfo.fileName.nameCharacterCode = UTF_16LE;

	/* File name length */
	if (pstsGetNameInfo->length <= FILE_NAME_LENGTH)
	{
		nameLength = pstsGetNameInfo->length;
	}
	else
	{
		nameLength = FILE_NAME_LENGTH;
	}
	currentPlayInfo.fileName.nameLength = nameLength;

	/* Save current file name information */
	for (vnameIndex = (U8) 0; vnameIndex < nameLength; vnameIndex++)
	{
		currentPlayInfo.fileName.Name[vnameIndex]
				= pstsGetNameInfo->name[vnameIndex];
	}
	/* Name string end flag */
	currentPlayInfo.fileName.Name[nameLength] = (U8) 0;
}
#ifdef RESUME_FUNCTION_USED
/*****************************************************************************
 * ID                : 1.0
 * Outline           : Load resume information as current play information
 * Include           : none
 * Declaration       : static void LoadResumeInfo(U8 mediaType)
 * Description       : Load resume information as current play information
 *                   :
 * Argument          : mediaType, specified USB/SD
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void LoadResumeInfo(U8 mediaType)
{
	if (mediaType == MEDIA_TYPE_USB)
	{
		/* Load USB media resume information */
		currentPlayInfo.resumeInfo = resumeMediaInfo.usbResumeInfo;
	}
#ifdef SD_USED
	else if (mediaType == MEDIA_TYPE_SD)
	{
		/* Load SD media resume information */
		currentPlayInfo.resumeInfo = resumeMediaInfo.sdResumeInfo;
	}
#endif
	else
	{
		/* Load other media resume information */
	}
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Save current play information to resume media information
 * Include           : none
 * Declaration       : static void SaveResumeInfo(U8 mediaType)
 * Description       : Save current play information to resume media information
 *                   :
 * Argument          : mediaType, specified USB/SD
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void SaveResumeInfo(U8 mediaType)
{
	if (mediaType == MEDIA_TYPE_USB)
	{
		/* Save to USB media resume information */
		resumeMediaInfo.usbResumeInfo = currentPlayInfo.resumeInfo;
	}
#ifdef SD_USED
	else if (mediaType == MEDIA_TYPE_SD)
	{
		/* Save to SD media resume information */
		resumeMediaInfo.sdResumeInfo = currentPlayInfo.resumeInfo;
	}
#endif
	else
	{
		/* Save to other media resume information */
	}
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Check if resume
 * Include           : none
 * Declaration       : static BOOLEAN IsResume(U8 mediaType)
 * Description       : Check if resume
 *                   : based on -
 *                   : (1)Media information
 *                   :   vendor ID & Word information
 *                   :   Product ID & Word information
 *                   :   Serial ID & Word information
 *                   : (2)Total folder number
 *                   : (3)Total file number
 *                   : (4)Volume ID
 *                   : (5)File size
 * Argument          : mediaType, specified USB/SD media
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static BOOLEAN IsResume(U8 mediaType)
{
	BOOLEAN returnValue = TRUE;
	U8 fileSizeIndex = (U8) 0;
#ifdef SAVE_MORE_MEDIA_INFO
	U8 vnameIndex = (U8)0;
	U8 wordIndex = (U8)0;
#endif

	if (mediaType == MEDIA_TYPE_USB)
	{
		/* USB media resume judgment */
		/*** (1)Check Media information ***/
#ifdef SAVE_MORE_MEDIA_INFO
		/* Judge "length" & "word" */
		if((tempMediaInfo.vendor.length != resumeMediaInfo.usbResumeInfo.mediaInfo.vendor.length) ||
				(tempMediaInfo.product.length != resumeMediaInfo.usbResumeInfo.mediaInfo.product.length) ||
				(tempMediaInfo.serial.length != resumeMediaInfo.usbResumeInfo.mediaInfo.serial.length)
		)
		{
			/* Not resume */
			returnValue = FALSE;
		}
		else
		{
			/* Length matched then further judge */
			for(wordIndex = (U8)0;wordIndex < tempMediaInfo.vendor.length; wordIndex++)
			{
				if(tempMediaInfo.vendor.word[wordIndex] != resumeMediaInfo.usbResumeInfo.mediaInfo.vendor.word[wordIndex])
				{
					returnValue = FALSE;
					break;
				}
			}
			for(wordIndex = (U8)0;wordIndex < tempMediaInfo.vendor.length; wordIndex++)
			{
				if(tempMediaInfo.product.word[wordIndex] != resumeMediaInfo.usbResumeInfo.mediaInfo.product.word[wordIndex])
				{
					returnValue = FALSE;
					break;
				}
			}
			for(wordIndex = (U8)0;wordIndex < tempMediaInfo.vendor.length; wordIndex++)
			{
				if(tempMediaInfo.serial.word[wordIndex] != resumeMediaInfo.usbResumeInfo.mediaInfo.serial.word[wordIndex])
				{
					returnValue = FALSE;
					break;
				}
			}

		}
#endif
		if ((tempMediaInfo.vendor.id
				!= resumeMediaInfo.usbResumeInfo.mediaInfo.vendor.id)
				|| (tempMediaInfo.product.id
						!= resumeMediaInfo.usbResumeInfo.mediaInfo.product.id)
				|| (tempMediaInfo.serial.id
						!= resumeMediaInfo.usbResumeInfo.mediaInfo.serial.id)
#ifdef SAVE_MORE_MEDIA_INFO
		||
		(returnValue == FALSE)/* Length & word not matched then not resume and save information */
#endif
		)
		{
			/* If not same as saved information then not resume
			 * and save current media information */

			returnValue = FALSE;
		}
		else
		{
			/* If same as saved information then resume */
			returnValue = TRUE;
		}

		/*** (2)Check total folder number ***/
		if ((resumeMediaInfo.usbResumeInfo.totalFolderNum
				!= currentMediaStatus.usb.totalFolderNum) || (returnValue
				== FALSE))
		{
			returnValue = FALSE;
		}
		else
		{
			/* If file number matched then resume */
			returnValue = TRUE;
		}

		/*** (3)Check total file number ***/
		if ((resumeMediaInfo.usbResumeInfo.totalFileNum
				!= currentMediaStatus.usb.totalFileNum) || (returnValue
				== FALSE))
		{
			returnValue = FALSE;
		}
		else
		{
			/* If file number matched then resume */
			returnValue = TRUE;
		}

		/*** (4)Check volume ID ***/
		if ((resumeMediaInfo.usbResumeInfo.volumeID
				!= currentMediaStatus.usb.volumeID) || (returnValue == FALSE))
		{
			returnValue = FALSE;
		}
		else
		{
			/* If file number matched then resume */
			returnValue = TRUE;
		}

		/*** (5)Check file size ***/
		if (returnValue == TRUE)
		{
			/* Continue to check file size */
			for (fileSizeIndex = (U8) 0; fileSizeIndex < FILE_SIZE_LENGTH; fileSizeIndex++)
			{
				if (resumeMediaInfo.usbResumeInfo.fileSize[fileSizeIndex]
						!= currentMediaStatus.usb.fileSize[fileSizeIndex])
				{
					/* File size not matched */
					returnValue = FALSE;
					break;
				}
			}
		}
		else
		{
			/* Not resumed */
		}
	}/* USB media resume judgment End */
#ifdef SD_USED
	else if (mediaType == MEDIA_TYPE_SD)
	{
		/* SD media resume judgment */
		/*** (1)Check Media information ***/
#ifdef SAVE_MORE_MEDIA_INFO
		/* Judge "length" & "word" */
		if((tempMediaInfo.vendor.length != resumeMediaInfo.sdResumeInfo.mediaInfo.vendor.length) ||
				(tempMediaInfo.product.length != resumeMediaInfo.sdResumeInfo.mediaInfo.product.length) ||
				(tempMediaInfo.serial.length != resumeMediaInfo.sdResumeInfo.mediaInfo.serial.length)
		)
		{
			/* Not resume */
			returnValue = FALSE;
		}
		else
		{
			/* Length matched then further judge */
			for(wordIndex = (U8)0;wordIndex < tempMediaInfo.vendor.length; wordIndex++)
			{
				if(tempMediaInfo.vendor.word[wordIndex] != resumeMediaInfo.sdResumeInfo.mediaInfo.vendor.word[wordIndex])
				{
					returnValue = FALSE;
					break;
				}
			}
			for(wordIndex = (U8)0;wordIndex < tempMediaInfo.vendor.length; wordIndex++)
			{
				if(tempMediaInfo.product.word[wordIndex] != resumeMediaInfo.sdResumeInfo.mediaInfo.product.word[wordIndex])
				{
					returnValue = FALSE;
					break;
				}
			}
			for(wordIndex = (U8)0;wordIndex < tempMediaInfo.vendor.length; wordIndex++)
			{
				if(tempMediaInfo.serial.word[wordIndex] != resumeMediaInfo.sdResumeInfo.mediaInfo.serial.word[wordIndex])
				{
					returnValue = FALSE;
					break;
				}
			}

		}
#endif
		if ((tempMediaInfo.vendor.id
				!= resumeMediaInfo.sdResumeInfo.mediaInfo.vendor.id)
				|| (tempMediaInfo.product.id
						!= resumeMediaInfo.sdResumeInfo.mediaInfo.product.id)
				|| (tempMediaInfo.serial.id
						!= resumeMediaInfo.sdResumeInfo.mediaInfo.serial.id)
#ifdef SAVE_MORE_MEDIA_INFO
		||
		(returnValue == FALSE)/* Length & word not matched then not resume and save information */
#endif
		)
		{
			/* If not same as saved information then not resume
			 * and save current media information */

			returnValue = FALSE;
		}
		else
		{
			/* If same as saved information then resume */
			returnValue = TRUE;
		}

		/*** (2)Check total folder number ***/
		if ((resumeMediaInfo.sdResumeInfo.totalFolderNum
				!= currentMediaStatus.sd.totalFolderNum) || (returnValue
				== FALSE))
		{
			returnValue = FALSE;
		}
		else
		{
			/* If file number matched then resume */
			returnValue = TRUE;
		}

		/*** (3)Check total file number ***/
		if ((resumeMediaInfo.sdResumeInfo.totalFileNum
				!= currentMediaStatus.sd.totalFileNum)
				|| (returnValue == FALSE))
		{
			returnValue = FALSE;
		}
		else
		{
			/* If file number matched then resume */
			returnValue = TRUE;
		}

		/*** (4)Check volume ID ***/
		if ((resumeMediaInfo.sdResumeInfo.volumeID
				!= currentMediaStatus.sd.volumeID) || (returnValue == FALSE))
		{
			returnValue = FALSE;
		}
		else
		{
			/* If file number matched then resume */
			returnValue = TRUE;
		}

		/*** (5)Check file size ***/
		if (returnValue == TRUE)
		{
			/* Continue to check file size */
			for (fileSizeIndex = (U8) 0; fileSizeIndex < FILE_SIZE_LENGTH; fileSizeIndex++)
			{
				if (resumeMediaInfo.usbResumeInfo.fileSize[fileSizeIndex]
						!= currentMediaStatus.usb.fileSize[fileSizeIndex])
				{
					/* File size not matched */
					returnValue = FALSE;
					break;
				}
			}
		}
		else
		{
			/* Not resumed */
		}
	}/* SD media resume judgment End */
#endif
	else
	{
		/* Invalid media */
		returnValue = FALSE;
	}
	return returnValue;
}
#endif
/*****************************************************************************
 * ID                : 1.0
 * Outline           : Check if disconnected
 * Include           : none
 * Declaration       : static BOOLEAN IsDisconnected(void)
 * Description       : Check if disconnected
 *                   : Check CDB[9]&CDB[12], ID = 83H
 * Argument          : none
 * Return Value      : TRUE, if disconnection is detected
 *                   : FALSE, if disconnection is not detected
 * Calling Functions : none
 *****************************************************************************/
static BOOLEAN IsDisconnected(void)
{
	BOOLEAN returnValue = FALSE;

	if ((stsConnectStatus.usbConnectInfo == USB_DISCONNECTION_DETECTED)
			|| (stsConnectStatus.usbConnectInfo
					== USB_DISCON_DETECTED_STS_CHANGED)
#ifdef SD_USED
			|| (stsConnectStatus.sdConnectInfo == SD_DISCONNECTION_DETECTED)
			|| (stsConnectStatus.sdConnectInfo
					== SD_DISCON_DETECTED_STS_CHANGED)
#endif
	)
	{
		returnValue = TRUE;
	}
	else
	{
		returnValue = FALSE;
	}

	return returnValue;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Check if connected
 * Include           : none
 * Declaration       : static BOOLEAN IsConnected(void)
 * Description       : Check if connected
 *                   : Check CDB[9]&CDB[12], ID = 83H
 * Argument          : none
 * Return Value      : TRUE, if connection is detected
 *                   : FALSE, if connection is not detected
 * Calling Functions : none
 *****************************************************************************/
static BOOLEAN IsConnected(void)
{
	BOOLEAN returnValue = FALSE;
	if ((stsConnectStatus.usbConnectInfo == USB_CONNECTION_DETECTED)
			|| (stsConnectStatus.usbConnectInfo == USB_CON_DETECTED_STS_CHANGED)
#ifdef SD_USED
			|| (stsConnectStatus.sdConnectInfo == SD_CONNECTION_DETECTED)
			|| (stsConnectStatus.sdConnectInfo == SD_CON_DETECTED_STS_CHANGED)
#endif
	)
	{
		StartCounter(&U32gAE1ConnectGuardTimer);
		returnValue = TRUE;
	}
	else
	{
		returnValue = FALSE;
	}

	return returnValue;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Check Power up
 * Include           : none
 * Declaration       : static BOOLEAN IsPowerUp(void)
 * Description       : Check Power up
 * Argument          : none
 * Return Value      : TRUE, if power up
 *                   : FALSE, if not power up
 * Calling Functions : none
 *****************************************************************************/
static BOOLEAN IsPowerUp(void)
{
	BOOLEAN returnValue = FALSE;

	if (U8HostState == HOST_STATE_PERIPHERAL_POWERUP)
	{
		returnValue = TRUE;
	}
	else
	{
		returnValue = FALSE;
	}

	return returnValue;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : To get Playback Mode code
 * Include           : none
 * Declaration       : static U8 GetPlaybackMode(const t_PlayState * playState)
 * Description       : To get Playback Mode code
 *                   : based on PlayState which from host
 * Argument          : playState, pointer to Playstate buffer
 * Return Value      : Playback mode code parameter
 * Calling Functions : none
 *****************************************************************************/
static U8 GetPlaybackMode(const t_PlayState * playState)
{
	return (PlaybackModeCodeTable[playState->U8EnableRandom][playState->U8EnableScan][playState->U8RepeatMode]);
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : To get and clear message from host
 * Include           : none
 * Declaration       : static AE1_Message GetAndClearMsgFromHost(void)
 * Description       : To get message from host
 *                   : and clear related message
 * Argument          : none
 * Return Value      : current valid message need to be processed
 * Calling Functions : none
 *****************************************************************************/
static AE1_Message GetAndClearMsgFromHost(void)
{
	AE1_Message Msg, MsgC;
	U8 u8_i = (U8) 0;

	Msg = AE1_MSG_NULL;
	MsgC = AE1_MSG_PLAY_PAUSE;
	if (TMsgHostToAE1.AE1Message != AE1_MSG_NULL)
	{
		/* Search the nearest msg and clear it */
		for (u8_i = (U8) 0; u8_i < AE1_MSG_NUMBER; u8_i++)
		{
			/* Search match message */
			if (MsgC & TMsgHostToAE1.AE1Message)
			{
				Msg = MsgC;
				/* Clear message bit */
				TMsgHostToAE1.AE1Message = TMsgHostToAE1.AE1Message & (~Msg);
				break;
			}
			MsgC = MsgC << 1;
		}

	}
	else
	{
		/* No message coming */
	}

	return Msg;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Save USB media information if connected and file analysis complete
 * Include           : none
 * Declaration       : static void saveConnectedMediaInfo_USB(void)
 * Description       : Save USB media information if connected and file analysis complete
 *                   : isfileValid/totalFolderNum/totalFileNum
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void saveConnectedMediaInfo_USB(void)
{
	U8 fileSizeIndex = (U8) 0;

	if (pstsUsbSdConnection->connectStatus == CON_STS_CONNECTED)
	{
		/* Save current media status */
		currentMediaStatus.usb.connectSts = CONNECTED;
		if (pstsUsbSdConnection->fileSysStatus == FILE_STS_ANALYSIS_COMPLETED)
		{
			/* If file system analysis complete then save media information */
			currentMediaStatus.usb.totalFolderNum = ReadU16FromBuf(
					(U8*) &(pstsUsbSdConnection->folderTotalNum))
					- ((U8) ROOT_FOLDER_NUM - (U8) 1);
			currentMediaStatus.usb.totalFileNum = ReadU16FromBuf(
					(U8*) &(pstsUsbSdConnection->fileTotalNum));
			currentMediaStatus.usb.volumeID = ReadU32FromBuf(
					(U8*) &(pstsUsbSdConnection->volumeID));
			for (fileSizeIndex = (U8) 0; fileSizeIndex < FILE_SIZE_LENGTH; fileSizeIndex++)
			{
				currentMediaStatus.usb.fileSize[fileSizeIndex]
						= pstsUsbSdConnection->fileSize[fileSizeIndex];
			}
			if (currentMediaStatus.usb.totalFileNum != (U16) 0)
			{
				currentMediaStatus.usb.isFileValid = TRUE;
			}
			else
			{
				currentMediaStatus.usb.isFileValid = FALSE;
			}
		}
		else
		{
			/* Wait file system analysis over */
		}
	}
	else
	{
		/* Ignore other situation */
	}
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Save USB media information if disconnected
 * Include           : none
 * Declaration       : static void ClearMediaConnectInfo_USB(void)
 * Description       : Save USB media information if disconnected
 *                   : isfileValid/totalFolderNum/totalFileNum
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void ClearMediaConnectInfo_USB(void)
{
	/* Save current media status */
	currentMediaStatus.usb.connectSts = DISCONNECTED;
	currentMediaStatus.usb.isFileValid = FALSE;
	currentMediaStatus.usb.totalFolderNum = (U16) 0x0000;
	currentMediaStatus.usb.totalFileNum = (U16) 0x0000;
}
#ifdef SD_USED
/*****************************************************************************
 * ID                : 1.0
 * Outline           : Save SD media information if connected and file analysis complete
 * Include           : none
 * Declaration       : static void saveConnectedMediaInfo_SD(void)
 * Description       : Save SD media information if connected and file analysis complete
 *                   : isfileValid/totalFolderNum/totalFileNum
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void saveConnectedMediaInfo_SD(void)
{
	U8 fileSizeIndex = (U8) 0;

	/* Save current media status */
	currentMediaStatus.sd.connectSts = CONNECTED;
	if (pstsUsbSdConnection->fileSysStatus == FILE_STS_ANALYSIS_COMPLETED)
	{
		/* If file system analysis complete then save media information */
		currentMediaStatus.sd.totalFolderNum = ReadU16FromBuf(
				(U8*) &(pstsUsbSdConnection->folderTotalNum))
				- ((U8) ROOT_FOLDER_NUM - (U8) 1);
		currentMediaStatus.sd.totalFileNum = ReadU16FromBuf(
				(U8*) &(pstsUsbSdConnection->fileTotalNum));
		currentMediaStatus.sd.volumeID = ReadU32FromBuf(
				(U8*) &(pstsUsbSdConnection->volumeID));
		for (fileSizeIndex = (U8) 0; fileSizeIndex < FILE_SIZE_LENGTH; fileSizeIndex++)
		{
			currentMediaStatus.sd.fileSize[fileSizeIndex]
					= pstsUsbSdConnection->fileSize[fileSizeIndex];
		}
		if (currentMediaStatus.sd.totalFileNum != (U16) 0)
		{
			currentMediaStatus.sd.isFileValid = TRUE;
		}
		else
		{
			currentMediaStatus.sd.isFileValid = FALSE;
		}
	}
	else
	{
		/* Wait file system analysis over */
	}
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Save SD media information if disconnected
 * Include           : none
 * Declaration       : static void ClearMediaConnectInfo_SD(void)
 * Description       : Save SD media information if disconnected
 *                   : isfileValid/totalFolderNum/totalFileNum
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void ClearMediaConnectInfo_SD(void)
{
	/* Save current media status */
	currentMediaStatus.sd.connectSts = DISCONNECTED;
	currentMediaStatus.sd.isFileValid = FALSE;
	currentMediaStatus.sd.totalFolderNum = (U16) 0x0000;
	currentMediaStatus.sd.totalFileNum = (U16) 0x0000;
}
#endif

/*****************************************************************************
 * ID                : 1.0
 * Outline           : To check which media can be played
 * Include           : none
 * Declaration       : static U8 MediaCanBePlayed(void)
 * Description       : To check which media can be played
 * Argument          : none
 * Return Value      : MEDIA_TYPE_USB, USB media can be played
 *                   : MEDIA_TYPE_SD, SD media can be played
 * Calling Functions : none
 *****************************************************************************/
static U8 MediaCanBePlayed(void)
{
	U8 mediaCanBePlayed = MEDIA_TYPE_INVALID;

	if (TPlayState.U8Media == MEDIA_TYPE_USB)
	{
		/* Media is USB */
		if (currentMediaStatus.usb.connectSts == CONNECTED)
		{
			mediaCanBePlayed = (U8) MEDIA_TYPE_USB;
		}
#ifdef SD_USED
		else if (currentMediaStatus.sd.connectSts == CONNECTED)
		{
			mediaCanBePlayed = (U8) MEDIA_TYPE_SD;
		}
#endif
		else
		{
			/* Other media */
		}
	}
#ifdef SD_USED
	else if (TPlayState.U8Media == MEDIA_TYPE_SD)
	{
		/* Media is SD */
		if (currentMediaStatus.sd.connectSts == CONNECTED)
		{
			mediaCanBePlayed = (U8) MEDIA_TYPE_SD;
		}
		else if (currentMediaStatus.usb.connectSts == CONNECTED)
		{
			mediaCanBePlayed = (U8) MEDIA_TYPE_USB;
		}
		else
		{
			/* Other media */
		}
	}
#endif
	else
	{
		/* Ignore other media */
	}

	return mediaCanBePlayed;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : To get media number on media list table
 * Include           : none
 * Declaration       : static U8 GetCurrentMediaNum(U8 specifiedMediaType)
 * Description       : To get media number on media list table
 * Argument          : specifiedMediaType, specified media type.
 * Return Value      : media number in media list table
 * Calling Functions : none
 *****************************************************************************/
static U8 GetCurrentMediaNum(U8 specifiedMediaType)
{
	U8 mediaTableIndex = (U8) 0;
	U8 returnValue = (U8) 0xFF;

	for (mediaTableIndex = (U8) 0; mediaTableIndex < (sizeof(mediaListTable)
			/ sizeof(mediaListTable[0])); mediaTableIndex++)
	{
		if (specifiedMediaType == mediaListTable[mediaTableIndex])
		{
			/* Specified media number was found in table */
			returnValue = mediaTableIndex;
			break;
		}
		else
		{
			/* Continue to find the current media number */
		}
	}

	return returnValue;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : To get media number on media list table
 * Include           : none
 * Declaration       : static U8 GetNextMediaNum(U8 specifiedMediaType)
 * Description       : To get media number on media list table
 * Argument          : specifiedMediaType, specified media type.
 * Return Value      : media number in media list table
 * Calling Functions : none
 *****************************************************************************/
static U8 GetNextMediaNum(U8 specifiedMediaType)
{
	U8 mediaTableIndex = (U8) 0;
	U8 returnValue = (U8) 0xFF;

	for (mediaTableIndex = (U8) 0; mediaTableIndex < (sizeof(mediaListTable)
			/ sizeof(mediaListTable[0])); mediaTableIndex++)
	{
		if (specifiedMediaType == mediaListTable[mediaTableIndex])
		{
			/* Specified media number was found in table */
			if (mediaTableIndex == ((sizeof(mediaListTable)
					/ sizeof(mediaListTable[0])) - (U8) 1))
			{
				/* If specified media is the last media in table
				 * point to the first media */
				returnValue = (U8) 0x00;
			}
			else
			{
				/* If specified media is not the last media in table
				 * then point to next media in table */
				returnValue = mediaTableIndex + (U8) 1;
			}
			break;
		}
		else
		{
			/* Continue to find the current media number */
		}
	}

	return returnValue;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : To check specified media validity
 * Include           : none
 * Declaration       : static U8 GetMediaNum(U8 specifiedMediaNum)
 * Description       : To check specified media validity
 * Argument          : specifiedMediaNum, specified media number on media list table
 * Return Value      : TRUE, if specified media is valid
 *                   : FALSE, if specified media is not valid
 * Calling Functions : none
 *****************************************************************************/
static BOOLEAN IsMediaValid(U8 specifiedMediaNum)
{
	BOOLEAN returnValue = FALSE;

	switch (mediaListTable[specifiedMediaNum])
	{
	case MEDIA_TYPE_USB:
		/* Check USB validity */
		if (currentMediaStatus.usb.connectSts == CONNECTED)
		{
			returnValue = TRUE;
		}
		else
		{
			/* If USB is not valid or total file number in USB is 0 */
			returnValue = FALSE;
		}
		break;
#ifdef SD_USED
	case MEDIA_TYPE_SD:
		/* Check SD validity */
		if (currentMediaStatus.sd.connectSts == CONNECTED)
		{
			returnValue = TRUE;
		}
		else
		{
			/* If SD is not valid or total file number in SD is 0 */
			returnValue = FALSE;
		}
		break;
#endif
	default:
		/* Not valid media */
		returnValue = FALSE;
		break;
	}

	return returnValue;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : To get media information(USB)
 * Include           : none
 * Declaration       : static void GetMediaInfo_USB(void)
 * Description       : To get media information(USB)
 *                   : NOTE:
 *                   :    !! Auto variable must not used here,
 *                   :       because we have used the TaskWait()
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void GetMediaInfo_USB(void)
{
	/* (A)Get vendor information */
	sendCmd_MediaInfoAcq(TARGET_USB_VENDOR_INFO);
	TaskRecallEvent = U8AE1ComRxBuf;
	TaskRecallValue = U8gcmdCounter;
	TaskWait();
	RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
	if (RecCmd->Status != IDB4_STS_INFO_ACQUIRED)
	{
		/* Get information disabled */
	}
	else
	{
		/* Save information */
		SaveTempMediaInfo(TARGET_USB_VENDOR_INFO);
	}

	/* (B)Get product information */
	sendCmd_MediaInfoAcq(TARGET_USB_PRODUCT_INFO);
	TaskRecallEvent = U8AE1ComRxBuf;
	TaskRecallValue = U8gcmdCounter;
	TaskWait();
	RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
	if (RecCmd->Status != IDB4_STS_INFO_ACQUIRED)
	{
		/* Get information disabled */
	}
	else
	{
		/* Save information */
		SaveTempMediaInfo(TARGET_USB_PRODUCT_INFO);
	}

	/* (C)Get serial information */
	sendCmd_MediaInfoAcq(TARGET_USB_SERIAL_NUM);
	TaskRecallEvent = U8AE1ComRxBuf;
	TaskRecallValue = U8gcmdCounter;
	TaskWait();
	RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
	if (RecCmd->Status != IDB4_STS_INFO_ACQUIRED)
	{
		/* Get information disabled */
	}
	else
	{
		/* Save information */
		SaveTempMediaInfo(TARGET_USB_SERIAL_NUM);
	}
	/* Get current media information End */
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : To get media information(SD)
 * Include           : none
 * Declaration       : static void GetMediaInfo_SD(void)
 * Description       : To get media information(SD)
 *                   : NOTE:
 *                   :    !! Auto variable must not used here,
 *                   :       because we have used the TaskWait()
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void GetMediaInfo_SD(void)
{
	/* (A)Get vendor information */
	sendCmd_MediaInfoAcq(TARGET_SD_VENDOR_INFO);
	TaskRecallEvent = U8AE1ComRxBuf;
	TaskRecallValue = U8gcmdCounter;
	TaskWait();
	RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
	if (RecCmd->Status != IDB4_STS_INFO_ACQUIRED)
	{
		/* Get information disabled */
	}
	else
	{
		/* Save information */
		SaveTempMediaInfo(TARGET_SD_VENDOR_INFO);
	}

	/* (B)Get product information */
	sendCmd_MediaInfoAcq(TARGET_SD_PRODUCT_INFO);
	TaskRecallEvent = U8AE1ComRxBuf;
	TaskRecallValue = U8gcmdCounter;
	TaskWait();
	RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
	if (RecCmd->Status != IDB4_STS_INFO_ACQUIRED)
	{
		/* Get information disabled */
	}
	else
	{
		/* Save information */
		SaveTempMediaInfo(TARGET_SD_PRODUCT_INFO);
	}

	/* (C)Get serial information */
	sendCmd_MediaInfoAcq(TARGET_SD_SERIAL_NUM);
	TaskRecallEvent = U8AE1ComRxBuf;
	TaskRecallValue = U8gcmdCounter;
	TaskWait();
	RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
	if (RecCmd->Status != IDB4_STS_INFO_ACQUIRED)
	{
		/* Get information disabled */
	}
	else
	{
		/* Save information */
		SaveTempMediaInfo(TARGET_SD_SERIAL_NUM);
	}
	/* Get current media information End */
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Save media information and inform display when start playback
 * Include           : none
 * Declaration       : static void SaveAndInformDisplayToStartPlay(void)
 * Description       : Save media information
 *                   : Save media information for resume
 *                   : inform display when start playback
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void SaveAndInformDisplayToStartPlay(void)
{
	U8 fileSizeIndex = (U8) 0;
	U16 centrePosFolderNum = (U16) 0;

	/* Save current media information for next power-on*/
	TPlayState.U8Media = currentPlayInfo.resumeInfo.deviceType;

	/* Save current media info */
	SaveCurrentPlaybackMediaInfo();

	/* Get music information when playback */
	InfoUpdatedFileNum = (U16) 0;
	AE1MsgForDisplay.currentFile.device
			= (enum_device) currentPlayInfo.resumeInfo.deviceType;
	AE1MsgForDisplay.currentFile.fileNumInCurrentFolder
			= currentPlayInfo.filePositionInCurrentFolder;
	AE1MsgForDisplay.currentFile.currentFolderInfo.firstFileNumInFolder
			= currentPlayInfo.firstFileNumInFolder;
	AE1MsgForDisplay.currentFile.currentFolderInfo.containFileNum
			= currentPlayInfo.totalFileNumInCurrentFolder;

	/* Save current play information if Start/Resume */
	if (currentPlayInfo.resumeInfo.deviceType == MEDIA_TYPE_USB)
	{
		currentPlayInfo.resumeInfo.totalFolderNum
				= currentMediaStatus.usb.totalFolderNum;
		currentPlayInfo.resumeInfo.totalFileNum
				= currentMediaStatus.usb.totalFileNum;
		currentPlayInfo.resumeInfo.volumeID = currentMediaStatus.usb.volumeID;
		for (fileSizeIndex = (U8) 0; fileSizeIndex < FILE_SIZE_LENGTH; fileSizeIndex++)
		{
			currentPlayInfo.resumeInfo.fileSize[fileSizeIndex]
					= currentMediaStatus.usb.fileSize[fileSizeIndex];
		}
	}
#ifdef SD_USED
	else if (currentPlayInfo.resumeInfo.deviceType == MEDIA_TYPE_SD)
	{
		currentPlayInfo.resumeInfo.totalFolderNum
				= currentMediaStatus.sd.totalFolderNum;
		currentPlayInfo.resumeInfo.totalFileNum
				= currentMediaStatus.sd.totalFileNum;
		currentPlayInfo.resumeInfo.volumeID = currentMediaStatus.sd.volumeID;
		for (fileSizeIndex = (U8) 0; fileSizeIndex < FILE_SIZE_LENGTH; fileSizeIndex++)
		{
			currentPlayInfo.resumeInfo.fileSize[fileSizeIndex]
					= currentMediaStatus.sd.fileSize[fileSizeIndex];
		}
	}
#endif
	else
	{
		/* Ignore other media */
	}

	/* Check how to get folder information for first time */
	centrePosFolderNum = currentPlayInfo.resumeInfo.totalFolderNum
			+ (U8) ROOT_FOLDER_NUM;
	centrePosFolderNum = centrePosFolderNum - (U8) 1;
	centrePosFolderNum = centrePosFolderNum / (U8) 2;
	if (currentPlayInfo.currentFolderNum <= centrePosFolderNum)
	{
		/* Upside of folder series */
		getFolderInfoCtl = UPSIDE;
	}
	else
	{
		/* Downside of folder series */
		getFolderInfoCtl = DOWNSIDE;
	}

	/* Save resume information */
	SaveResumeInfo(currentPlayInfo.resumeInfo.deviceType);

	/* After check complete, inform display current media status */
	UpdateAE1MsgForDisp_MediaInfo();
	DispMessage |= (U32) DISP_MSG_DISK_CHANGE;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Set playback command parameters to zero
 * Include           : none
 * Declaration       : static void setPlaybackParas_Zero(void)
 * Description       : Same as Outline above
 * Argument          : None
 * Return Value      : None
 * Calling Functions : None
 *****************************************************************************/
static void setPlaybackParas_Zero(void)
{
	cmdPlaybackPausePara.specifiedPlaybackPos_Hour = (U16) 0x0000;
	cmdPlaybackPausePara.specifiedPlaybackPos_Minute = (U8) 0x00;
	cmdPlaybackPausePara.specifiedPlaybackPos_Second = (U8) 0x00;
	cmdPlaybackPausePara.resumInfo[0] = 0x00;
	cmdPlaybackPausePara.resumInfo[1] = 0x00;
	cmdPlaybackPausePara.resumInfo[2] = 0x00;
	cmdPlaybackPausePara.resumInfo[3] = 0x00;
	cmdPlaybackPausePara.resumInfo[4] = 0x00;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : To Start/Resume play USB media
 * Include           : none
 * Declaration       : static void UsbPlayback(void)
 * Description       : To Start/Resume play USB media
 *                   : NOTE:
 *                   :    MAYBE TRANSFER TO "PLAYBACK" STATE.
 *                   : NOTE:
 *                   :    !! Auto variable must not used here,
 *                   :       because we have used the TaskWait()
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void UsbPlayback(void)
{
	/* (2)-1-1 Prepare for judgment of Start/Resume */
	/* A. Get total folder number information */
	/* B. Get total file number information */
	/* C. Get volume ID information */
	/* D. Get file size information */
	/* E. Get media information: vendor ID, product ID, serial ID */

#ifdef RESUME_FUNCTION_USED
	/* (2)-1-2 Judge whether Start/Resume or not */
	/* Confirm resume */
	if (IsResume(MEDIA_TYPE_USB))
	{
		/* Get resume information from record */
		LoadResumeInfo(MEDIA_TYPE_USB);

		/* Resume playback */
		cmdPlaybackPausePara.specifiedFileOrFolderNum
				= currentPlayInfo.resumeInfo.fileNum;
		cmdPlaybackPausePara.specifiedPlaybackPos_Hour
				= currentPlayInfo.resumeInfo.timeInfo.hour;
		cmdPlaybackPausePara.specifiedPlaybackPos_Minute
				= currentPlayInfo.resumeInfo.timeInfo.minute;
		cmdPlaybackPausePara.specifiedPlaybackPos_Second
				= currentPlayInfo.resumeInfo.timeInfo.second;
		cmdPlaybackPausePara.resumInfo[0] = 0x00;
		cmdPlaybackPausePara.resumInfo[1] = 0x00;
		cmdPlaybackPausePara.resumInfo[2] = 0x00;
		cmdPlaybackPausePara.resumInfo[3] = 0x00;
		cmdPlaybackPausePara.resumInfo[4] = 0x00;
		sendCmd_PlaybackPause(RESUME_OR_DIRECT_FILE_PLAY, &cmdPlaybackPausePara);
		TaskRecallEvent = U8AE1ComRxBuf;
		TaskRecallValue = U8gcmdCounter;
		TaskWait();
		RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
		if (RecCmd->Status == ID90_CASE_CMD_NOT_EXED)
		{
#ifdef DEBUG_ON
			/* Service_Error_PrintInfo("PlayPauseCmdErr"); *//*Setting error process */
#endif
		}
		else
		{
			if (pstsPlayback_Pause->playStatus == PLAY_STS_PLAYBACK_STARTED)
			{
				/* Playback started */
				currentPlayInfo.currentFolderNum = ReadU16FromBuf(
						(U8*) &(pstsPlayback_Pause->subjectFolderNum));
				currentPlayInfo.resumeInfo.fileNum = ReadU16FromBuf(
						(U8*) &(pstsPlayback_Pause->fileNum));
				currentPlayInfo.resumeInfo.deviceType = MEDIA_TYPE_USB;

				/* Update message for display
				 * When device connected->disconnected->connected,
				 * Information for display should change correspondingly,
				 * - current file change
				 * - disk change
				 * Here is "disk change" information.
				 * both above message are necessary. */
				UpdateAE1MsgForDisp_StartPlay();
				DispMessage |= (U32) DISP_MSG_DISK_CHANGE;
				UpdateAE1MsgForDisp_ResumePlaytime();

				/* Save resume information */
				SaveResumeInfo(currentPlayInfo.resumeInfo.deviceType);

				SaveAndInformDisplayToStartPlay();

				/* Start to monitor playback time for switching next file if invalid file exists */
				prevPlaybackTime = (U8) 0;
				newPlaybackTime = (U8) 0;
				StartGuardTimer(&U16gMonitorPlayTime);
				//
				EgAE1Task = PLAYBACK;
			}/* End of playback started */
			else
			{
				/* Not playback started then re-send command */
			}
		}/* End of command was executed */
	}/* End of resume playback */
	else
#endif
	{
		/* Start play from beginning */
		cmdPlaybackPausePara.specifiedFileOrFolderNum = (U16) 0x0001;
		setPlaybackParas_Zero();
		/* Start play from beginning */
		sendCmd_PlaybackPause(RESUME_OR_DIRECT_FILE_PLAY, &cmdPlaybackPausePara);
		TaskRecallEvent = U8AE1ComRxBuf;
		TaskRecallValue = U8gcmdCounter;
		TaskWait();
		RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
		if (RecCmd->Status == ID90_CASE_CMD_NOT_EXED)
		{
#ifdef DEBUG_ON
			Service_Error_PrintInfo("PlayPauseCmdErr"); /* Setting error process */
#endif
		}
		else
		{
			if (pstsPlayback_Pause->playStatus == PLAY_STS_PLAYBACK_STARTED)
			{
				/* Playback started */
				currentPlayInfo.currentFolderNum = ReadU16FromBuf(
						(U8*) &(pstsPlayback_Pause->subjectFolderNum));
				currentPlayInfo.resumeInfo.fileNum = ReadU16FromBuf(
						(U8*) &(pstsPlayback_Pause->fileNum));
				currentPlayInfo.resumeInfo.deviceType = MEDIA_TYPE_USB;

				/* Update message for display
				 * When device connected->disconnected->connected,
				 * Information for display should change correspondingly,
				 * - current file change
				 * - disk change
				 * Here is "disk change" information.
				 * above both message are necessary. */
				UpdateAE1MsgForDisp_StartPlay();
				DispMessage |= (U32) DISP_MSG_DISK_CHANGE;

				/* Save resume information */
				SaveResumeInfo(currentPlayInfo.resumeInfo.deviceType);

				SaveAndInformDisplayToStartPlay();

				/* Start to monitor playback time for switching next file if invalid file type exists */
				prevPlaybackTime = (U8) 0;
				newPlaybackTime = (U8) 0;
				StartGuardTimer(&U16gMonitorPlayTime);

				EgAE1Task = PLAYBACK;
			}/* End of playback started */
			else
			{
				/* Not playback started then re-send command */

			}
		}/* End of command was executed */
	}/* End of "if not resume playback" */
}
#ifdef SD_USED
/*****************************************************************************
 * ID                : 1.0
 * Outline           : To Start/Resume play SD media
 * Include           : none
 * Declaration       : static void SdPlayback(void)
 * Description       : To Start/Resume play SD media
 *                   : NOTE:
 *                   :    MAYBE TRANSFER TO "PLAYBACK" STATE.
 *                   : NOTE:
 *                   :    !! Auto variable must not used here,
 *                   :       because we have used the TaskWait()
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void SdPlayback(void)
{
	/* (2)-1-1 Prepare for judgment of Start/Resume */
	/* A. Get total folder number information */
	/* B. Get total file number information */
	/* C. Get volume ID information */
	/* D. Get file size information */
	/* E. Get media information: vendor ID, product ID, serial ID */

#ifdef RESUME_FUNCTION_USED
	/* (2)-2-2 Judge whether Start/Resume or not */
	/* Confirm resume */
	if (IsResume(MEDIA_TYPE_SD))
	{
		/* Get resume information from record */
		LoadResumeInfo(MEDIA_TYPE_SD);

		/* Resume playback */
		cmdPlaybackPausePara.specifiedFileOrFolderNum
				= currentPlayInfo.resumeInfo.fileNum;
		cmdPlaybackPausePara.specifiedPlaybackPos_Hour
				= currentPlayInfo.resumeInfo.timeInfo.hour;
		cmdPlaybackPausePara.specifiedPlaybackPos_Minute
				= currentPlayInfo.resumeInfo.timeInfo.minute;
		cmdPlaybackPausePara.specifiedPlaybackPos_Second
				= currentPlayInfo.resumeInfo.timeInfo.second;
		cmdPlaybackPausePara.resumInfo[0] = 0x00;
		cmdPlaybackPausePara.resumInfo[1] = 0x00;
		cmdPlaybackPausePara.resumInfo[2] = 0x00;
		cmdPlaybackPausePara.resumInfo[3] = 0x00;
		cmdPlaybackPausePara.resumInfo[4] = 0x00;
		sendCmd_PlaybackPause(RESUME_OR_DIRECT_FILE_PLAY, &cmdPlaybackPausePara);
		TaskRecallEvent = U8AE1ComRxBuf;
		TaskRecallValue = U8gcmdCounter;
		TaskWait();
		RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
		if (RecCmd->Status == ID90_CASE_CMD_NOT_EXED)
		{
#ifdef DEBUG_ON
			/* Service_Error_PrintInfo("PlayPauseCmdErr"); *//* Setting error process */
#endif
		}
		else
		{
			if (pstsPlayback_Pause->playStatus == PLAY_STS_PLAYBACK_STARTED)
			{
				/* Playback started */
				currentPlayInfo.currentFolderNum = ReadU16FromBuf(
						(U8*) &(pstsPlayback_Pause->subjectFolderNum));
				currentPlayInfo.resumeInfo.fileNum = ReadU16FromBuf(
						(U8*) &(pstsPlayback_Pause->fileNum));
				currentPlayInfo.resumeInfo.deviceType = MEDIA_TYPE_SD;

				/* Update message for display
				 * When device connected->disconnected->connected,
				 * Information for display should change correspondingly,
				 * - current file change
				 * - disk change
				 * Here is "disk change" information.
				 * both above message are necessary. */
				UpdateAE1MsgForDisp_StartPlay();
				DispMessage |= (U32) DISP_MSG_DISK_CHANGE;
				UpdateAE1MsgForDisp_ResumePlaytime();

				/* Save resume information */
				SaveResumeInfo(currentPlayInfo.resumeInfo.deviceType);

				SaveAndInformDisplayToStartPlay();

				/* Start to monitor playback time for switching next file if invalid file exists */
				prevPlaybackTime = (U8) 0;
				newPlaybackTime = (U8) 0;
				StartGuardTimer(&U16gMonitorPlayTime);

				EgAE1Task = PLAYBACK;
			}/* End of playback started */
			else
			{
				/* Not playback started then re-send command */

			}
		}/* End of command was executed */
	}/* End of resume playback */
	else
#endif
	{
		/* Start play from beginning */
		cmdPlaybackPausePara.specifiedFileOrFolderNum = (U16) 0x0001;
		setPlaybackParas_Zero();
		/* Start play from beginning */
		sendCmd_PlaybackPause(RESUME_OR_DIRECT_FILE_PLAY, &cmdPlaybackPausePara);
		TaskRecallEvent = U8AE1ComRxBuf;
		TaskRecallValue = U8gcmdCounter;
		TaskWait();
		RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
		if (RecCmd->Status == ID90_CASE_CMD_NOT_EXED)
		{
#ifdef DEBUG_ON
			Service_Error_PrintInfo("PlayPauseCmdErr"); /* Setting error process */
#endif
		}
		else
		{
			if (pstsPlayback_Pause->playStatus == PLAY_STS_PLAYBACK_STARTED)
			{
				/* Playback started */
				currentPlayInfo.currentFolderNum = ReadU16FromBuf(
						(U8*) &(pstsPlayback_Pause->subjectFolderNum));
				currentPlayInfo.resumeInfo.fileNum = ReadU16FromBuf(
						(U8*) &(pstsPlayback_Pause->fileNum));
				currentPlayInfo.resumeInfo.deviceType = MEDIA_TYPE_SD;

				/* Update message for display
				 * When device connected->disconnected->connected,
				 * Information for display should change correspondingly,
				 * - current file change
				 * - disk change
				 * Here is "disk change" information.
				 * both above message are necessary. */
				UpdateAE1MsgForDisp_StartPlay();
				DispMessage |= (U32) DISP_MSG_DISK_CHANGE;

				/* Save resume information */
				SaveResumeInfo(currentPlayInfo.resumeInfo.deviceType);

				SaveAndInformDisplayToStartPlay();

				/* Start to monitor playback time for switching next file if invalid file exists */
				prevPlaybackTime = (U8) 0;
				newPlaybackTime = (U8) 0;
				StartGuardTimer(&U16gMonitorPlayTime);

				EgAE1Task = PLAYBACK;
			}/* End of playback started */
			else
			{
				/* Not playback started then re-send command */

			}
		}/* End of command was executed */
	}/* End of "if not resume playback" */
}
#endif

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update current play info
 *                   : Mark if need update folder info
 *                   : Update display message
 *                   : Save resume info
 * Include           : none
 * Declaration       : static void updateCurrentPlayInfo(void)
 * Description       : Same as Outline above
 * Argument          : None
 * Return Value      : None
 * Calling Functions : None
 *****************************************************************************/
static void updateCurrentPlayInfo(void)
{
	/* Check whether folder is changed */
	currentNewFolderNum = ReadU16FromBuf(
			(U8*) &(pstsPlayback_Pause->subjectFolderNum));
	currentPlayInfo.resumeInfo.fileNum = ReadU16FromBuf(
			(U8*) &(pstsPlayback_Pause->fileNum));

	if (currentNewFolderNum > currentPlayInfo.currentFolderNum)
	{
		/* Normally, playback turn is clockwise when playback automatically */
		/* Is Folder Information Complete */
		isFolderInfoComplete = FALSE;
		getFolderInfoCtl = CLOCKWISE;
	}
	else if (currentNewFolderNum < currentPlayInfo.currentFolderNum)
	{
		/* When repeat/random playback to the end automatically, should re-get information  */
		/* Is Folder Information Complete */
		isFolderInfoComplete = FALSE;
		getFolderInfoCtl = UPSIDE;
	}
	else
	{
		getFolderInfoCtl = KEEP_SILENT;
	}
	currentPlayInfo.currentFolderNum = currentNewFolderNum;

	/* Update display information */
	UpdateAE1MsgForDisp_NewFile();
	UpdateAE1MsgForDisp_ClearPlaytime();

	/* Save resume information */
	SaveResumeInfo(currentPlayInfo.resumeInfo.deviceType);
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Clear specified variable.
 * Include           : none
 * Declaration       : static void StartCounter(U32* guardCounter)
 * Description       : Clear specified variable.
 * Argument          : * guardCounter, pointer to variable which need to be cleared.
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void StartCounter(U32* guardCounter)
{
	*guardCounter = (U32) 0;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Check connect number
 * Include           : none
 * Declaration       : static BOOLEAN IsConnectMediaOvertime(void)
 * Description       : If connecting media is overtime, then return TRUE.
 * Argument          : None
 * Return Value      : TRUE, connect media overtime
 *                   : FALSE, connect media not overtime
 * Calling Functions : None
 *****************************************************************************/
static BOOLEAN IsConnectMediaOvertime(void)
{
	BOOLEAN returnValue = FALSE;

	if (U32gAE1ConnectGuardTimer > CONNECT_OVERTIME_IN_MILLISECOND)
	{
		returnValue = TRUE;
	}
	else
	{
		returnValue = FALSE;
	}

	return returnValue;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : To check connection(connected/disconnected)
 * Include           : none
 * Declaration       : static void CheckConnection(void)
 * Description       : To check connection(connected/disconnected)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void CheckConnection(void)
{
	/* 1. Check disconnection */
	if (IsDisconnected())
	{
		/* Update media status information */
		if ((stsConnectStatus.usbConnectInfo == USB_DISCONNECTION_DETECTED)
				|| (stsConnectStatus.usbConnectInfo
						== USB_DISCON_DETECTED_STS_CHANGED))
		{
			ClearMediaConnectInfo_USB();
			/* Update display information */
			UpdateAE1MsgForDisp_UsbDisconnected();
		}
		else
		{
			/* Do nothing if connected */
		}

#ifdef SD_USED
		if ((stsConnectStatus.sdConnectInfo == SD_DISCONNECTION_DETECTED)
				|| (stsConnectStatus.sdConnectInfo
						== SD_DISCON_DETECTED_STS_CHANGED))
		{
			ClearMediaConnectInfo_SD();
			/* Update display information */
			UpdateAE1MsgForDisp_SdDisconnected();
		}
		else
		{
			/* Do nothing if connected */
		}
#endif
		/* Update display for current media disconnection */
		if (((currentPlayInfo.resumeInfo.deviceType == MEDIA_TYPE_USB)
				&& (currentMediaStatus.usb.connectSts == DISCONNECTED))
#ifdef SD_USED
				|| ((currentPlayInfo.resumeInfo.deviceType == MEDIA_TYPE_SD)
						&& (currentMediaStatus.sd.connectSts == DISCONNECTED))
#endif
		)
		{
			/* Update display information, clear current file information */
			UpdateAE1MsgForDisp_ClearCurrentFile();
		}/* End of update display information when current media is disconnected */
		else
		{
			/* If not current media is disconnected then do nothing */
		}

		/* Judge next media validity whether current media is disconnected */
		if (IsMediaValid(
				GetCurrentMediaNum(currentPlayInfo.resumeInfo.deviceType))
				!= TRUE)
		{
			/* If current media is disconnected then check next media validity */
			if (IsMediaValid(
					GetNextMediaNum(currentPlayInfo.resumeInfo.deviceType)))
			{
				/* If next media is valid then set connection & playback.*/
				switch (mediaListTable[GetNextMediaNum(
						currentPlayInfo.resumeInfo.deviceType)])
				{
				case MEDIA_TYPE_USB:
					TPlayState.U8Media = MEDIA_TYPE_USB;
					break;
#ifdef SD_USED
				case MEDIA_TYPE_SD:
					TPlayState.U8Media = MEDIA_TYPE_SD;
					break;
#endif
				default:
					break;
				}
			}
			else
			{
				/* Next media is also invalid */
				TPlayState.U8Media = MEDIA_TYPE_INVALID;
			}
			StartCounter(&U32gAE1ConnectGuardTimer);
			/* Print message for waiting connection */
			DispMessage |= DISP_MSG_WARN_NOMEDIA;
			EgAE1Task = DEV_DISCONNECTED;
		}/* End of current media is invalid */
		else
		{
			/* If current media is connected then continue */
		}
	}/* End of disconnection process */

	/* 2. Check connection */
	if (IsConnected())
	{
		/* Connected is detected */
		if ((stsConnectStatus.usbConnectInfo == USB_CONNECTION_DETECTED)
				|| (stsConnectStatus.usbConnectInfo
						== USB_CON_DETECTED_STS_CHANGED))
		{
			currentMediaStatus.usb.connectSts = CONNECTED;
			UpdateAE1MsgForDisp_UsbConnected();
		}
#ifdef SD_USED
		if ((stsConnectStatus.sdConnectInfo == SD_CONNECTION_DETECTED)
				|| (stsConnectStatus.sdConnectInfo
						== SD_CON_DETECTED_STS_CHANGED))
		{
			currentMediaStatus.sd.connectSts = CONNECTED;
			UpdateAE1MsgForDisp_SdConnected();
		}
#endif
	}

	/* Clear temporary information */
	ClearSponSTS_Connect();
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : To check if over-current happened
 * Include           : none
 * Declaration       : static void CheckOvercurrent(void)
 * Description       : To check if over-current happened
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void CheckOvercurrent(void)
{
	if (stsConnectStatus.overCurrent == OVERCURRENT_STS_DETECTED)
	{
		/* To do: should shut down and re-initialize */

		/* Clear temporary information */
		ClearSponSTS_Connect();
#ifdef DEBUG_ON
		Service_Error_PrintInfo("OverCurrent!"); /* Setting error process */
		/* To do: Should inform host to power down! */
#endif
	}
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : To return minimum value of 2 values
 * Include           : none
 * Declaration       : static U16 minimum(U16 bufDepth, U16 distance)
 * Description       : To return minimum value of 2 values
 * Argument          : bufDepth, folder buffer depth
 *                   : distance, distance to the 1st folder or the last folder
 * Return Value      : minimum value of 2 value
 * Calling Functions : none
 *****************************************************************************/
static U16 minimum(U16 bufDepth, U16 distance)
{
	if (bufDepth >= distance)
	{
		return distance;
	}
	else
	{
		return bufDepth;
	}
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Switch to next media if it is valid
 * Include           : none
 * Declaration       : static void SwitchMedia(void)
 * Description       : Switch to next media if it is valid
 * Argument          : None
 * Return Value      : None
 * Calling Functions : None
 *****************************************************************************/
static void SwitchMedia(void)
{
	if (IsMediaValid(GetNextMediaNum(currentPlayInfo.resumeInfo.deviceType)))
	{
		/* If next media is valid then set connection & playback.*/
		switch (mediaListTable[GetNextMediaNum(
				currentPlayInfo.resumeInfo.deviceType)])
		{
		case MEDIA_TYPE_USB:
			TPlayState.U8Media = MEDIA_TYPE_USB;
			/* Print message for waiting connection */
			DispMessage |= DISP_MSG_WARN_ANYING;
			break;
#ifdef SD_USED
		case MEDIA_TYPE_SD:
			TPlayState.U8Media = MEDIA_TYPE_SD;
			/* Print message for waiting connection */
			DispMessage |= DISP_MSG_WARN_ANYING;
			break;
#endif
		default:
			break;
		}
		StartCounter(&U32gAE1ConnectGuardTimer);
		EgAE1Task = DEV_DISCONNECTED;
	}
	else
	{
		/* Ignore when next media is also invalid */
	}
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : To get music file information
 * Include           : none
 * Declaration       : static void GetMusicInfo(void)
 * Description       : To get music file information
 *                   : Total time/file name/Tag-Title/Tag-Artist/Tag-Album
 *                   : NOTE:
 *                   :    !! Auto variable must not used here,
 *                   :       because we have used the TaskWait()
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void GetMusicInfo(void)
{
#if 1
	switch (EgplaySubstate)
	{
	case GET_FOLDER_INFO:
		/* Get folder information */
		cmdGetFolderInfo.standard = CURRENT_FOLDER;
		cmdGetFolderInfo.specifiedFolderNum = (U16) 0x0000;
		sendCmd_FolderInfo(&cmdGetFolderInfo);
		TaskRecallEvent = U8AE1ComRxBuf;
		TaskRecallValue = U8gcmdCounter;
		TaskWait();
		RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
		if (RecCmd->Status == IDA4_STS_INFO_ACQUIRED)
		{
			currentPlayInfo.totalFileNumInCurrentFolder = ReadU16FromBuf(
					(U8*) &(pstsGetFolderInfo->includeFileNum));
			currentPlayInfo.firstFileNumInFolder = ReadU16FromBuf(
					(U8*) &(pstsGetFolderInfo->firstFileNum));
			currentPlayInfo.filePositionInCurrentFolder
					= currentPlayInfo.resumeInfo.fileNum + (U16) 1;
			currentPlayInfo.filePositionInCurrentFolder
					= currentPlayInfo.filePositionInCurrentFolder
							- ReadU16FromBuf(
									(U8*) &(pstsGetFolderInfo->firstFileNum));

			/* Save resume information */
			SaveResumeInfo(currentPlayInfo.resumeInfo.deviceType);

			/* Update display information */
			/* Current folder number */
			AE1MsgForDisplay.currentFile.currentFolderInfo.folderNum
					= currentPlayInfo.currentFolderNum;
			/* Current file position in current folder */
			AE1MsgForDisplay.currentFile.fileNumInCurrentFolder
					= currentPlayInfo.filePositionInCurrentFolder;
			/* Total file number that current folder contained */
			AE1MsgForDisplay.currentFile.currentFolderInfo.containFileNum
					= currentPlayInfo.totalFileNumInCurrentFolder;
			/* First File Number */
			AE1MsgForDisplay.currentFile.currentFolderInfo.firstFileNumInFolder
					= currentPlayInfo.firstFileNumInFolder;
			DispMessage |= (U32) DISP_MSG_FILE_CHANGE;

			/* Judge current file if it is in current folder */
			if (getFolderInfoCtl == KEEP_SILENT)
			{
				/* If folder not changed then get total time */
				EgplaySubstate = GET_TOTAL_TIME;
			}
			else
			{
				/* If folder is changed or the 1st time then get folder information */
				EgplaySubstate = GET_FOLDER_NAME;
			}
		}
		else
		{
			/* Get folder information disabled then re-get */
		}

		break;
	case GET_FOLDER_NAME:
		/* Check new music file happened */
		if (currentPlayInfo.resumeInfo.fileNum != InfoUpdatedFileNum)
		{
			InfoUpdatedFileNum = currentPlayInfo.resumeInfo.fileNum;
			EgplaySubstate = GET_FOLDER_INFO;
			break;
		}
		else
		{
			/* Not new music */
		}

		/* Get folder name */
		cmdGetNameInfo.target = TARGET_FOLDER;
		cmdGetNameInfo.standard = NAME_TYPE_CURRENT;
		cmdGetNameInfo.specifiedNum = (U16) 0x0000;
		sendCmd_NameInfo(&cmdGetNameInfo);
		TaskRecallEvent = U8AE1ComRxBuf;
		TaskRecallValue = U8gcmdCounter;
		TaskWait();
		RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
		if (RecCmd->Status == IDB0_STS_NAME_ACQUIRED)
		{
			/* Update display information */
			UpdateAE1MsgForDisp_CurrentFolderName();

			/* Get folder buffer information */
			switch (getFolderInfoCtl)
			{
			case UPSIDE:
				/* Current folder position: upside of folder series */
				/* For the 1st time, get and fill all buffer
				 * default: get as clockwise direction */
				UpdateAE1MsgForDisp_ClearFolderBuf();
				AE1MsgForDisplay.currentFile.folderInfoBuf.folderDirection
						= CLOCKWISE;
				AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex
						= (U8) 0;
				/* Fill current folder information to folder buffer */
				AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[0]
						= AE1MsgForDisplay.currentFile.currentFolderInfo;
				if (currentPlayInfo.currentFolderNum == (U16) ROOT_FOLDER_NUM)
				{
					/* Current folder is root folder */
					if (currentPlayInfo.resumeInfo.totalFolderNum != (U16) 1)
					{
						folderBufNumPrevious = (U16) 0;
						folderBufNumAfter = minimum(
								(U16) (FOLDER_INFO_BUF_DEPTH - (U8) 2),
								((currentPlayInfo.resumeInfo.totalFolderNum
										- currentPlayInfo.currentFolderNum)
										+ (U16) ROOT_FOLDER_NUM) - (U16) 1);
						specifiedFolderNum = currentPlayInfo.currentFolderNum
								+ (U16) 1;
						updateFolderBufIndex = (U8) 1;/* Folder buffer index to be update */
						EgplaySubstate = GET_OTHER_FOLDER_INFO;
					}
					else
					{
						folderBufNumPrevious = (U16) 0;
						folderBufNumAfter = (U16) 0;
						EgplaySubstate = GET_TOTAL_TIME;
					}
				}
				else if (currentPlayInfo.currentFolderNum
						== ((currentPlayInfo.resumeInfo.totalFolderNum
								+ (U16) ROOT_FOLDER_NUM) - (U16) 1))
				{
					/* Current folder is the last folder */
					if (currentPlayInfo.resumeInfo.totalFolderNum != (U16) 1)
					{
						folderBufNumPrevious = (U16) 1;
						specifiedFolderNum = currentPlayInfo.currentFolderNum
								- (U16) 1;
						updateFolderBufIndex = FOLDER_INFO_BUF_DEPTH - (U8) 1;/* Folder buffer index to be update */
						folderBufNumAfter = (U16) 0;
						EgplaySubstate = GET_OTHER_FOLDER_INFO;
					}
					else
					{
						/* No folder information should be gotten */
						folderBufNumPrevious = (U16) 0;
						folderBufNumAfter = (U16) 0;
						EgplaySubstate = GET_TOTAL_TIME;
					}
				}
				else
				{
					/* Current folder is neither root folder nor the last folder */
					folderBufNumPrevious = (U16) 1;
					folderBufNumAfter = minimum(
							(U16) (FOLDER_INFO_BUF_DEPTH - (U8) 2),
							((currentPlayInfo.resumeInfo.totalFolderNum
									- currentPlayInfo.currentFolderNum)
									+ (U16) ROOT_FOLDER_NUM) - (U16) 1);
					/* First to get "+" then "-" */
					specifiedFolderNum = currentPlayInfo.currentFolderNum
							+ (U16) 1;
					updateFolderBufIndex = (U8) 1;/* Folder buffer index to be update */
					EgplaySubstate = GET_OTHER_FOLDER_INFO;
				}

				break;
			case DOWNSIDE:
				/* Current folder position: downside of folder series */
				/* For the 1st time, get and fill all buffer
				 * default: get as clockwise direction */
				UpdateAE1MsgForDisp_ClearFolderBuf();
				AE1MsgForDisplay.currentFile.folderInfoBuf.folderDirection
						= ANTI_CLOCKWISE;
				AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex
						= (U8) 1;
				/* Fill current folder information to folder buffer */
				AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[1]
						= AE1MsgForDisplay.currentFile.currentFolderInfo;
				if (currentPlayInfo.currentFolderNum == (U16) ROOT_FOLDER_NUM)
				{
					/* Current folder is root folder */
					if (currentPlayInfo.resumeInfo.totalFolderNum != (U16) 1)
					{
						folderBufNumPrevious = (U16) 0;
						folderBufNumAfter = (U16) 1;
						specifiedFolderNum = currentPlayInfo.currentFolderNum
								+ (U16) 1;
						updateFolderBufIndex = (U8) 2;/* Folder buffer index to be update */
						EgplaySubstate = GET_OTHER_FOLDER_INFO;
					}
					else
					{
						folderBufNumPrevious = (U16) 0;
						folderBufNumAfter = (U16) 0;
						EgplaySubstate = GET_TOTAL_TIME;
					}
				}
				else if (currentPlayInfo.currentFolderNum
						== ((currentPlayInfo.resumeInfo.totalFolderNum
								+ (U16) ROOT_FOLDER_NUM) - (U16) 1))
				{
					/* Current folder is the last folder */
					if (currentPlayInfo.resumeInfo.totalFolderNum != (U16) 1)
					{
						folderBufNumPrevious = minimum(
								(U16) (FOLDER_INFO_BUF_DEPTH - (U8) 2),
								currentPlayInfo.currentFolderNum
										- (U16) ROOT_FOLDER_NUM);
						specifiedFolderNum = currentPlayInfo.currentFolderNum
								- (U16) 1;
						updateFolderBufIndex = (U8) 0;/* Folder buffer index to be update */
						folderBufNumAfter = (U16) 0;
						EgplaySubstate = GET_OTHER_FOLDER_INFO;
					}
					else
					{
						/* No folder information should be gotten */
						folderBufNumPrevious = (U16) 0;
						folderBufNumAfter = (U16) 0;
						EgplaySubstate = GET_TOTAL_TIME;
					}
				}
				else
				{
					/* Current folder is neither root folder nor the last folder */
					folderBufNumPrevious = minimum(
							FOLDER_INFO_BUF_DEPTH - (U8) 2,
							currentPlayInfo.currentFolderNum
									- (U8) ROOT_FOLDER_NUM);
					folderBufNumAfter = (U16) 1;
					/* First to get "+" then "-" */
					specifiedFolderNum = currentPlayInfo.currentFolderNum
							+ (U16) 1;
					updateFolderBufIndex = (U8) 2;/* Folder buffer index to be update */
					EgplaySubstate = GET_OTHER_FOLDER_INFO;
				}

				break;
			case CLOCKWISE:
				/* Clock wise direction to update folder information */
				if (AE1MsgForDisplay.currentFile.folderInfoBuf.folderDirection
						== CLOCKWISE)
				{
					/* "+" -> "+" */
					/* If distance from current folder to the last folder is bigger than folder buffer depth
					 * then can get folder information */
					if ((((currentPlayInfo.resumeInfo.totalFolderNum
							+ (U8) ROOT_FOLDER_NUM) - (U8) 1)
							- currentPlayInfo.currentFolderNum)
							>= (FOLDER_INFO_BUF_DEPTH - (U8) 2))
					{
						/* If can get folder information */
						folderBufNumPrevious = (U16) 0;
						folderBufNumAfter = (U16) 1;
						specifiedFolderNum = currentPlayInfo.currentFolderNum
								+ FOLDER_INFO_BUF_DEPTH;
						specifiedFolderNum = specifiedFolderNum - (U8) 2;
						updateFolderBufIndex
								= AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex;
						updateFolderBufIndex = updateFolderBufIndex
								+ FOLDER_INFO_BUF_DEPTH;
						updateFolderBufIndex = updateFolderBufIndex - (U8) 1;
						updateFolderBufIndex = normalizeFolderBufIndex(
								updateFolderBufIndex);
						EgplaySubstate = GET_OTHER_FOLDER_INFO;
					}
					else
					{
						/* If can not get folder information then clear redundant folder buffer which is not necessary */
						/* Clear redundant folder buffer */
						UpdateAE1MsgForDisp_ClearSpecifiedFolderBuf(
								normalizeFolderBufIndex(
										AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex
												+ FOLDER_INFO_BUF_DEPTH
												- (U8) 1));
						folderBufNumPrevious = (U16) 0;
						folderBufNumAfter = (U16) 0;
						AE1MsgForDisplay.currentFile.folderInfoBuf.folderDirection
								= CLOCKWISE;
						AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex++;
						AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex
								&= (FOLDER_INFO_BUF_DEPTH - (U8) 1);
						DispMessage |= (U32) DISP_MSG_FOLDER_CHANGE;
						EgplaySubstate = GET_TOTAL_TIME;
					}
				}
				else
				{
					/* "-" -> "+" */
					/* If distance from current folder to the last folder is bigger than folder buffer depth
					 * then can get folder information */
					if (((currentPlayInfo.resumeInfo.totalFolderNum
							+ ((U8) ROOT_FOLDER_NUM - (U8) 1))
							- currentPlayInfo.currentFolderNum)
							>= (FOLDER_INFO_BUF_DEPTH - (U8) 2))
					{
						/* If can get folder information */
						folderBufNumPrevious = (U16) 0;
						folderBufNumAfter = minimum(
								(U16) (FOLDER_INFO_BUF_DEPTH - (U8) 2),
								(currentPlayInfo.resumeInfo.totalFolderNum
										- currentPlayInfo.currentFolderNum)
										+ ((U16) ROOT_FOLDER_NUM - (U16) 1));
						specifiedFolderNum = currentPlayInfo.currentFolderNum
								+ (U16) 1;
						updateFolderBufIndex
								= AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex;
						updateFolderBufIndex = updateFolderBufIndex + (U8) 2;
						updateFolderBufIndex = normalizeFolderBufIndex(
								updateFolderBufIndex);
						EgplaySubstate = GET_OTHER_FOLDER_INFO;
					}
					else
					{
						/* If can not get folder information then keep current status unchanged */
						if (currentPlayInfo.currentFolderNum
								!= (currentPlayInfo.resumeInfo.totalFolderNum
										+ ((U8) ROOT_FOLDER_NUM - (U8) 1)))
						{
							/* If current folder is not the last folder */
							/* Clear redundant folder buffer */
							ClearFolderBuf(
									(U16) (((AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex
											+ (U16) 2)
											+ (U16) (currentPlayInfo.resumeInfo.totalFolderNum
													- currentPlayInfo.currentFolderNum)
											+ ((U16) ROOT_FOLDER_NUM - (U16) 1))
											& ((U16) FOLDER_INFO_BUF_DEPTH
													- (U16) 1)),
									(U16) (FOLDER_INFO_BUF_DEPTH - (U16) 2
											- (currentPlayInfo.resumeInfo.totalFolderNum
													+ (U16) ROOT_FOLDER_NUM	- (U16) 1
													- currentPlayInfo.currentFolderNum)));
							folderBufNumPrevious = (U8) 0;
							folderBufNumAfter
									= minimum(
											(U16) (FOLDER_INFO_BUF_DEPTH
													- (U8) 2),
											(currentPlayInfo.resumeInfo.totalFolderNum
													- currentPlayInfo.currentFolderNum)
													+ ((U16) ROOT_FOLDER_NUM
															- (U16) 1));
							specifiedFolderNum
									= currentPlayInfo.currentFolderNum
											+ (U16) 1;
							updateFolderBufIndex
									= AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex
											+ (U8) 2;
							updateFolderBufIndex = normalizeFolderBufIndex(
									updateFolderBufIndex);
							EgplaySubstate = GET_OTHER_FOLDER_INFO;
						}
						else
						{
							/* If current folder is the last folder then keep folder buffer unchanged */
							ClearFolderBuf(
									(U16) (AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex
											+ (U16) 2),
									(U16) (FOLDER_INFO_BUF_DEPTH - (U16) 2));
							AE1MsgForDisplay.currentFile.folderInfoBuf.folderDirection
									= CLOCKWISE;
							AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex++;
							AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex
									&= (FOLDER_INFO_BUF_DEPTH - (U8) 1);
							DispMessage |= (U32) DISP_MSG_FOLDER_CHANGE;
							EgplaySubstate = GET_TOTAL_TIME;
						}
					}
				}
				break;
			case ANTI_CLOCKWISE:
				/* Anti-clock wise direction to update folder information */
				if (AE1MsgForDisplay.currentFile.folderInfoBuf.folderDirection
						== CLOCKWISE)
				{
					/* "+" -> "-" */
					/* If the distance from current folder to root is bigger than folder buffer depth
					 * then can get folder information */
					if ((currentPlayInfo.currentFolderNum
							- (U16) ROOT_FOLDER_NUM) >= (FOLDER_INFO_BUF_DEPTH
							- (U8) 2))
					{
						/* If can get enough folder information to fill all folder buffer */
						folderBufNumPrevious = minimum(
								(U16) (FOLDER_INFO_BUF_DEPTH - (U8) 2),
								currentPlayInfo.currentFolderNum
										- (U16) ROOT_FOLDER_NUM);
						specifiedFolderNum = currentPlayInfo.currentFolderNum
								- (U16) 1;
						updateFolderBufIndex
								= AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex;
						updateFolderBufIndex = updateFolderBufIndex
								+ FOLDER_INFO_BUF_DEPTH;
						updateFolderBufIndex = updateFolderBufIndex - (U8) 2;
						updateFolderBufIndex = normalizeFolderBufIndex(
								updateFolderBufIndex);
						folderBufNumAfter = (U16) 0;
						EgplaySubstate = GET_OTHER_FOLDER_INFO;
					}
					else
					{
						/* If can get part folder information to fill folder buffer */
						if (currentPlayInfo.currentFolderNum
								!= (U16) ROOT_FOLDER_NUM)
						{
							/* If current folder is not root then get part folder information */
							/* Clear redundant folder buffer information */
							ClearFolderBuf(
									(U16) (AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex
											+ (U16) 1),
									(U16) ((FOLDER_INFO_BUF_DEPTH - (U16) 2)
											- ((currentPlayInfo.currentFolderNum
													- (U16) ROOT_FOLDER_NUM))));
							folderBufNumPrevious
									= currentPlayInfo.currentFolderNum
											- (U8) ROOT_FOLDER_NUM;
							specifiedFolderNum
									= currentPlayInfo.currentFolderNum
											- (U16) 1;
							updateFolderBufIndex
									= AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex;
							updateFolderBufIndex = updateFolderBufIndex
									+ FOLDER_INFO_BUF_DEPTH;
							updateFolderBufIndex = updateFolderBufIndex
									- (U8) 2;
							updateFolderBufIndex = normalizeFolderBufIndex(
									updateFolderBufIndex);
							folderBufNumAfter = (U16) 0;
							EgplaySubstate = GET_OTHER_FOLDER_INFO;
						}
						else
						{
							folderBufNumPrevious = (U16) 0;
							folderBufNumAfter = (U16) 0;
							/* Clear redundant folder buffer information */
							UpdateAE1MsgForDisp_ClearSpecifiedFolderBuf(
									normalizeFolderBufIndex(
											AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex
													- (U8) 2));
							AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex--;
							AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex
									&= (FOLDER_INFO_BUF_DEPTH - (U8) 1);
							/* Get folder information complete then update */
							AE1MsgForDisplay.currentFile.folderInfoBuf.folderDirection
									= ANTI_CLOCKWISE;
							DispMessage |= (U32) DISP_MSG_FOLDER_CHANGE;
							EgplaySubstate = GET_TOTAL_TIME;
						}
					}
				}
				else
				{
					/* "-" -> "-" */
					if ((currentPlayInfo.currentFolderNum
							- (U16) ROOT_FOLDER_NUM) >= (FOLDER_INFO_BUF_DEPTH
							- (U8) 2))
					{
						/* If can get folder information */
						folderBufNumPrevious = (U16) 1;
						specifiedFolderNum = currentPlayInfo.currentFolderNum
								- (FOLDER_INFO_BUF_DEPTH - (U8) 2);
						updateFolderBufIndex
								= AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex
										+ (U8) 1;
						updateFolderBufIndex = normalizeFolderBufIndex(
								updateFolderBufIndex);
						folderBufNumAfter = (U16) 0;
						EgplaySubstate = GET_OTHER_FOLDER_INFO;
					}
					else
					{
						/* If can not get folder information then keep current status unchanged */
						/* Clear redundant folder buffer */
						UpdateAE1MsgForDisp_ClearSpecifiedFolderBuf(
								normalizeFolderBufIndex(
										AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex
												+ (U8) 1));
						folderBufNumPrevious = (U16) 0;
						folderBufNumAfter = (U16) 0;
						AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex--;
						AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex
								&= (FOLDER_INFO_BUF_DEPTH - (U8) 1);
						/* Get folder information complete then update */
						AE1MsgForDisplay.currentFile.folderInfoBuf.folderDirection
								= ANTI_CLOCKWISE;
						DispMessage |= (U32) DISP_MSG_FOLDER_CHANGE;
						EgplaySubstate = GET_TOTAL_TIME;
					}
				}
				break;
			case KEEP_SILENT:
				/* Ignore impossible state here */
				break;
			default:
				/* Ignore impossible state here */
				break;
			}
		}
		else
		{
			/* Get name disabled then re-get */
		}

		break;
	case GET_OTHER_FOLDER_INFO:
		/* Check new music file happened */
		if (currentPlayInfo.resumeInfo.fileNum != InfoUpdatedFileNum)
		{
			InfoUpdatedFileNum = currentPlayInfo.resumeInfo.fileNum;
			EgplaySubstate = GET_FOLDER_INFO;
			break;
		}
		else
		{
			/* Not new music */
		}

		/* 2-2. Get folder information */
		cmdGetFolderInfo.standard = SPECIFIED_FOLDER_NUM;
		cmdGetFolderInfo.specifiedFolderNum = specifiedFolderNum;
		sendCmd_FolderInfo(&cmdGetFolderInfo);
		TaskRecallEvent = U8AE1ComRxBuf;
		TaskRecallValue = U8gcmdCounter;
		TaskWait();
		RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
		if (RecCmd->Status == IDA4_STS_INFO_ACQUIRED)
		{
			/* Update folder buffer */
			AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[updateFolderBufIndex].folderNum
					= ReadU16FromBuf(
							(U8*) &(pstsGetFolderInfo->currentFolderNum));
			AE1MsgForDisplay.currentFile.folderInfoBuf.folderBuf[updateFolderBufIndex].containFileNum
					= ReadU16FromBuf((U8*) &(pstsGetFolderInfo->includeFileNum));
			EgplaySubstate = GET_OTHER_FOLDER_NAME;
		}
		else
		{
			/* Get folder information disabled then re-get */
		}

		break;
	case GET_OTHER_FOLDER_NAME:
		/* Check new music file happened */
		if (currentPlayInfo.resumeInfo.fileNum != InfoUpdatedFileNum)
		{
			InfoUpdatedFileNum = currentPlayInfo.resumeInfo.fileNum;
			EgplaySubstate = GET_FOLDER_INFO;
			break;
		}
		else
		{
			/* Not new music */
		}

		/* 2-2. Get folder name */
		cmdGetNameInfo.target = TARGET_FOLDER;
		cmdGetNameInfo.standard = NAME_TYPE_SPECIFIED;
		cmdGetNameInfo.specifiedNum = specifiedFolderNum;
		sendCmd_NameInfo(&cmdGetNameInfo);
		TaskRecallEvent = U8AE1ComRxBuf;
		TaskRecallValue = U8gcmdCounter;
		TaskWait();
		RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
		if (RecCmd->Status == IDB0_STS_NAME_ACQUIRED)
		{
			UpdateAE1MsgForDisp_FolderBufFolderName(updateFolderBufIndex);

			/* Update folder buffer */
			switch (getFolderInfoCtl)
			{
			case UPSIDE:
				/* Current folder position: upside of folder series */
				if (folderBufNumAfter != (U16) 0)
				{
					/* Continue to update next folder information */
					folderBufNumAfter--;
					if (folderBufNumAfter != (U16) 0)
					{
						specifiedFolderNum = specifiedFolderNum + (U16) 1;
						updateFolderBufIndex++;
						updateFolderBufIndex = normalizeFolderBufIndex(
								updateFolderBufIndex);
						EgplaySubstate = GET_OTHER_FOLDER_INFO;
					}
					else
					{
						/* Following folder information complete then previous folder information update */
						if (folderBufNumPrevious != (U16) 0)
						{
							specifiedFolderNum
									= currentPlayInfo.currentFolderNum
											- ((U8) ROOT_FOLDER_NUM - (U8) 1);
							updateFolderBufIndex = FOLDER_INFO_BUF_DEPTH
									- (U8) 1;
							EgplaySubstate = GET_OTHER_FOLDER_INFO;
						}
						else
						{
							DispMessage |= (U32) DISP_MSG_FOLDER_CHANGE;
							EgplaySubstate = GET_TOTAL_TIME;
						}
					}
				}
				else
				{
					/* Previous folder information update complete */
					/* Only 1 previous folder information can be gotten */
					DispMessage |= (U32) DISP_MSG_FOLDER_CHANGE;
					EgplaySubstate = GET_TOTAL_TIME;
				}
				break;
			case DOWNSIDE:
				/* Current folder position: downside of folder series */
				if (folderBufNumAfter != (U16) 0)
				{
					/* Continue to update next folder information */
					/* Should = 0, only 1 folder information can be gotten.
					 * following folder information complete */
					folderBufNumAfter--;

					/* Following folder information complete then previous folder information update */
					if (folderBufNumPrevious != (U16) 0)
					{
						specifiedFolderNum = currentPlayInfo.currentFolderNum
								- ((U8) ROOT_FOLDER_NUM - (U8) 1);
						updateFolderBufIndex = (U8) 0;
						EgplaySubstate = GET_OTHER_FOLDER_INFO;
					}
					else
					{
						DispMessage |= (U32) DISP_MSG_FOLDER_CHANGE;
						EgplaySubstate = GET_TOTAL_TIME;
					}
				}
				else
				{
					/* Previous folder information was update */
					if (folderBufNumPrevious != (U16) 0)
					{
						folderBufNumPrevious--;

						if (folderBufNumPrevious != (U16) 0)
						{
							specifiedFolderNum = specifiedFolderNum - (U16) 1;
							if (updateFolderBufIndex == (U8) 0)
							{
								/* UpdateFolderBufIndex */
								updateFolderBufIndex = FOLDER_INFO_BUF_DEPTH
										- (U8) 1;
							}
							else
							{
								updateFolderBufIndex = updateFolderBufIndex
										- (U8) 1;
								updateFolderBufIndex = normalizeFolderBufIndex(
										updateFolderBufIndex);
							}
							EgplaySubstate = GET_OTHER_FOLDER_INFO;
						}
						else
						{
							DispMessage |= (U32) DISP_MSG_FOLDER_CHANGE;
							EgplaySubstate = GET_TOTAL_TIME;
						}

					}
					else
					{
						DispMessage |= (U32) DISP_MSG_FOLDER_CHANGE;
						EgplaySubstate = GET_TOTAL_TIME;
					}
				}
				break;
			case CLOCKWISE:
				/* Clock wise direction to update folder information */
				if (AE1MsgForDisplay.currentFile.folderInfoBuf.folderDirection
						== CLOCKWISE)
				{
					/* "+" -> "+" */
					folderBufNumAfter--;/* Only one folder information need update */
					AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex++;
					AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex
							&= (FOLDER_INFO_BUF_DEPTH - (U8) 1);
					/* Get folder information complete then update */
					AE1MsgForDisplay.currentFile.folderInfoBuf.folderDirection
							= CLOCKWISE;
					DispMessage |= (U32) DISP_MSG_FOLDER_CHANGE;
					EgplaySubstate = GET_TOTAL_TIME;
				}
				else
				{
					/* "-" -> "+" */
					folderBufNumAfter--;/* Only one folder information need update */
					if (folderBufNumAfter != (U16) 0)
					{
						specifiedFolderNum++;
						updateFolderBufIndex++;
						updateFolderBufIndex = normalizeFolderBufIndex(
								updateFolderBufIndex);
						EgplaySubstate = GET_OTHER_FOLDER_INFO;
					}
					else
					{
						/* Get folder information complete then update */
						AE1MsgForDisplay.currentFile.folderInfoBuf.folderDirection
								= CLOCKWISE;
						AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex++;
						AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex
								&= (FOLDER_INFO_BUF_DEPTH - (U8) 1);
						DispMessage |= (U32) DISP_MSG_FOLDER_CHANGE;
						EgplaySubstate = GET_TOTAL_TIME;
					}
				}
				break;
			case ANTI_CLOCKWISE:
				/* Anti-clock wise direction to update folder information */
				if (AE1MsgForDisplay.currentFile.folderInfoBuf.folderDirection
						== CLOCKWISE)
				{
					/* "+" -> "-" */
					folderBufNumPrevious--;/* Only one folder information need update */
					if (folderBufNumPrevious != (U16) 0)
					{
						specifiedFolderNum--;
						updateFolderBufIndex--;
						updateFolderBufIndex = normalizeFolderBufIndex(
								updateFolderBufIndex);
						EgplaySubstate = GET_OTHER_FOLDER_INFO;
					}
					else
					{
						/* Get folder information complete then update */
						AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex--;
						AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex
								&= (FOLDER_INFO_BUF_DEPTH - (U8) 1);
						/* Get folder information complete then update */
						AE1MsgForDisplay.currentFile.folderInfoBuf.folderDirection
								= ANTI_CLOCKWISE;
						DispMessage |= (U32) DISP_MSG_FOLDER_CHANGE;
						EgplaySubstate = GET_TOTAL_TIME;
					}
				}
				else
				{
					/* "-" -> "-" */
					folderBufNumPrevious--;/* Only one folder information need update */
					AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex--;
					AE1MsgForDisplay.currentFile.folderInfoBuf.currentBufIndex
							&= (FOLDER_INFO_BUF_DEPTH - (U8) 1);
					/* Get folder information complete then update */
					AE1MsgForDisplay.currentFile.folderInfoBuf.folderDirection
							= ANTI_CLOCKWISE;
					DispMessage |= (U32) DISP_MSG_FOLDER_CHANGE;
					EgplaySubstate = GET_TOTAL_TIME;
				}
				break;
			case KEEP_SILENT:
				/* Ignore impossible state here */
				break;
			default:
				/* Ignore impossible state here */
				break;
			}
		}
		else
		{
			/* Get name disabled then re-get */
		}

		break;
	case GET_TOTAL_TIME:
		/* Check new music file happened */
		if (currentPlayInfo.resumeInfo.fileNum != InfoUpdatedFileNum)
		{
			InfoUpdatedFileNum = currentPlayInfo.resumeInfo.fileNum;
			EgplaySubstate = GET_FOLDER_INFO;
			break;
		}
		else
		{
			/* Not new music */
		}

		isFolderInfoComplete = TRUE;
		/* 2-1. Get total time */
		sendCmd_TimeInfo(TARGET_TOTAL_TIME);
		TaskRecallEvent = U8AE1ComRxBuf;
		TaskRecallValue = U8gcmdCounter;
		TaskWait();
		RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;

		if ((RecCmd->Status == IDB3CDB7_GOTTEN_DISABLED)
				|| (pstsTimeInfo->getResult == IDB3_TIME_BEING_PREPARED))
		{
			/* Get time disabled */
			/* Delay for a while then re-get information */
			StartGuardTimer(&U16gDelayResendCmd);
			EgplaySubstate = WAIT_REGET_TOTAL_TIME;
		}
		else
		{
			/* Update total time information */
			UpdateAE1MsgForDisp_TotalTime();
			EgplaySubstate = GET_FILE_NAME;
		}
		break;
	case WAIT_REGET_TOTAL_TIME:
		/* Check new music file happened */
		if (currentPlayInfo.resumeInfo.fileNum != InfoUpdatedFileNum)
		{
			InfoUpdatedFileNum = currentPlayInfo.resumeInfo.fileNum;
			EgplaySubstate = GET_FOLDER_INFO;
			break;
		}
		else
		{
			/* Not new music */
		}

		if (IsGuardTmrTimeout(U16gDelayResendCmd, DELAY_RESEND_CMD) == TRUE)
		{
			/* Re-get information */
			EgplaySubstate = GET_TOTAL_TIME;
		}
		else
		{
			/* Wait for re-get */
		}
		break;
	case GET_FILE_NAME:
		/* Check new music file happened */
		if (currentPlayInfo.resumeInfo.fileNum != InfoUpdatedFileNum)
		{
			InfoUpdatedFileNum = currentPlayInfo.resumeInfo.fileNum;
			EgplaySubstate = GET_FOLDER_INFO;
			break;
		}
		else
		{
			/* Not new music */
		}

		/* 2-2. Get file name */
		cmdGetNameInfo.target = TARGET_FILE;
		cmdGetNameInfo.standard = NAME_TYPE_CURRENT;
		cmdGetNameInfo.specifiedNum = 0x0000;
		sendCmd_NameInfo(&cmdGetNameInfo);
		TaskRecallEvent = U8AE1ComRxBuf;
		TaskRecallValue = U8gcmdCounter;
		TaskWait();
		RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
		if (RecCmd->Status == IDB0_STS_NAME_ACQUIRED)
		{
			/* Save current playback file name information */
			SaveCurrentFileNameInfo();

			/* Save resume information */
			SaveResumeInfo(currentPlayInfo.resumeInfo.deviceType);

			/* Update total time information */
			UpdateAE1MsgForDisp_FileName();

			EgplaySubstate = GET_TAG_TITLE;
		}
		else
		{
			/* Get name disabled then re-get */
		}

		break;
	case GET_TAG_TITLE:
		/* Check new music file happened */
		if (currentPlayInfo.resumeInfo.fileNum != InfoUpdatedFileNum)
		{
			InfoUpdatedFileNum = currentPlayInfo.resumeInfo.fileNum;
			EgplaySubstate = GET_FOLDER_INFO;
			break;
		}
		else
		{
			/* Not new music */
		}

		/* 2-3. Get tag information, Title */
		cmdGetTagInfo.tagType = TARGET_TITLE;
		cmdGetTagInfo.target = TARGET_CURRENT;
		cmdGetTagInfo.fileNum = (U16) 0x0000;
		sendCmd_TagInfo(&cmdGetTagInfo);
		TaskRecallEvent = U8AE1ComRxBuf;
		TaskRecallValue = U8gcmdCounter;
		TaskWait();
		RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;

		switch (RecCmd->Status)
		{
		case IDB1_STS_INFO_ACQUIRED:
			/* Information gotten */
			UpdateAE1MsgForDisp_TagInfo_Title();
			EgplaySubstate = GET_TAG_ARTIST;
			break;
		case IDB1_NO_TAG_INFO:
		case IDB1_TAG_ERROR:
			/* No information gotten */
			UpdateAE1MsgForDisp_NoTagInfoTitle();
			EgplaySubstate = GET_TAG_ARTIST;
			break;
		case IDB1_DECODE_NOT_COMPLETE:
		case IDB1_SET_FAILURE:
			/* Wait decode complete */
			/* Delay for a while then re-get information */
			StartGuardTimer(&U16gDelayResendCmd);
			EgplaySubstate = WAIT_REGET_TAG_TITLE;
			break;
		default:
			break;
		}

		break;
	case WAIT_REGET_TAG_TITLE:
		/* Check new music file happened */
		if (currentPlayInfo.resumeInfo.fileNum != InfoUpdatedFileNum)
		{
			InfoUpdatedFileNum = currentPlayInfo.resumeInfo.fileNum;
			EgplaySubstate = GET_FOLDER_INFO;
			break;
		}
		else
		{
			/* Not new music */
		}

		if (IsGuardTmrTimeout(U16gDelayResendCmd, DELAY_RESEND_CMD) == TRUE)
		{
			/* Re-get information */
			EgplaySubstate = GET_TAG_TITLE;
		}
		else
		{
			/* Wait for re-get */
		}
		break;
	case GET_TAG_ARTIST:
		/* Check new music file happened */
		if (currentPlayInfo.resumeInfo.fileNum != InfoUpdatedFileNum)
		{
			InfoUpdatedFileNum = currentPlayInfo.resumeInfo.fileNum;
			EgplaySubstate = GET_FOLDER_INFO;
			break;
		}
		else
		{
			/* Not new music */
		}

		/* 2-4. Get tag information, Artist */
		cmdGetTagInfo.tagType = TARGET_ARTIST_NAME;
		cmdGetTagInfo.target = TARGET_CURRENT;
		cmdGetTagInfo.fileNum = 0x0000;
		sendCmd_TagInfo(&cmdGetTagInfo);
		TaskRecallEvent = U8AE1ComRxBuf;
		TaskRecallValue = U8gcmdCounter;
		TaskWait();
		RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;

		switch (RecCmd->Status)
		{
		case IDB1_STS_INFO_ACQUIRED:
			/* Information gotten */
			UpdateAE1MsgForDisp_TagInfo_Artist();
			EgplaySubstate = GET_TAG_ALBUM;
			break;
		case IDB1_NO_TAG_INFO:
		case IDB1_TAG_ERROR:
			/* No information gotten */
			UpdateAE1MsgForDisp_NoTagInfoArtist();
			EgplaySubstate = GET_TAG_ALBUM;
			break;
		case IDB1_DECODE_NOT_COMPLETE:
		case IDB1_SET_FAILURE:
			/* Wait decode complete */
			/* Delay for a while then re-get information */
			StartGuardTimer(&U16gDelayResendCmd);
			EgplaySubstate = WAIT_REGET_TAG_ARTIST;
			break;
		default:
			break;
		}
		break;
	case WAIT_REGET_TAG_ARTIST:
		/* Check new music file happened */
		if (currentPlayInfo.resumeInfo.fileNum != InfoUpdatedFileNum)
		{
			InfoUpdatedFileNum = currentPlayInfo.resumeInfo.fileNum;
			EgplaySubstate = GET_FOLDER_INFO;
			break;
		}
		else
		{
			/* Not new music */
		}

		if (IsGuardTmrTimeout(U16gDelayResendCmd, DELAY_RESEND_CMD) == TRUE)
		{
			/* Re-get information */
			EgplaySubstate = GET_TAG_ARTIST;
		}
		else
		{
			/* Wait for re-get */
		}
		break;
	case GET_TAG_ALBUM:
		/* Check new music file happened */
		if (currentPlayInfo.resumeInfo.fileNum != InfoUpdatedFileNum)
		{
			InfoUpdatedFileNum = currentPlayInfo.resumeInfo.fileNum;
			EgplaySubstate = GET_FOLDER_INFO;
			break;
		}
		else
		{
			/* Not new music */
		}

		/* 2-5. Get tag information, Album */
		cmdGetTagInfo.tagType = TARGET_ALBUM_NAME;
		cmdGetTagInfo.target = TARGET_CURRENT;
		cmdGetTagInfo.fileNum = 0x0000;
		sendCmd_TagInfo(&cmdGetTagInfo);
		TaskRecallEvent = U8AE1ComRxBuf;
		TaskRecallValue = U8gcmdCounter;
		TaskWait();
		RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;

		switch (RecCmd->Status)
		{
		case IDB1_STS_INFO_ACQUIRED:
			/* Information gotten */
			UpdateAE1MsgForDisp_TagInfo_Album();
			/* Update display file information */
			DispMessage |= (U32) DISP_MSG_FILE_CHANGE;
			AE1MsgForDisplay.currentFile.InfoUpdate = TRUE;

			EgplaySubstate = IDLE;
			break;
		case IDB1_NO_TAG_INFO:
		case IDB1_TAG_ERROR:
			/* No information gotten */
			UpdateAE1MsgForDisp_NoTagInfoAlbum();
			/* Update display file information */
			DispMessage |= (U32) DISP_MSG_FILE_CHANGE;
			AE1MsgForDisplay.currentFile.InfoUpdate = TRUE;

			EgplaySubstate = IDLE;
			break;
		case IDB1_DECODE_NOT_COMPLETE:
		case IDB1_SET_FAILURE:
			/* Wait decode complete */
			/* Delay for a while then re-get information */
			StartGuardTimer(&U16gDelayResendCmd);
			EgplaySubstate = WAIT_REGET_TAG_ALBUM;
			break;
		default:
			break;
		}
		break;
	case WAIT_REGET_TAG_ALBUM:
		/* Check new music file happened */
		if (currentPlayInfo.resumeInfo.fileNum != InfoUpdatedFileNum)
		{
			InfoUpdatedFileNum = currentPlayInfo.resumeInfo.fileNum;
			EgplaySubstate = GET_FOLDER_INFO;
			break;
		}
		else
		{
			/* Not new music */
		}

		if (IsGuardTmrTimeout(U16gDelayResendCmd, DELAY_RESEND_CMD) == TRUE)
		{
			/* Re-get information */
			EgplaySubstate = GET_TAG_ALBUM;
		}
		else
		{
			/* Wait for re-get */
		}
		break;
	case IDLE:
		/* Check new music file happened */
		if (currentPlayInfo.resumeInfo.fileNum != InfoUpdatedFileNum)
		{
			InfoUpdatedFileNum = currentPlayInfo.resumeInfo.fileNum;
			AE1MsgForDisplay.currentFile.InfoUpdate = FALSE;

			/* Pause released after switch file or folder */
			if (AE1MsgForDisplay.currentFile.PlayOrPause == PLAY_STS_PAUSE)
			{
				/* Update display information, Pause -> Play */
				AE1MsgForDisplay.currentFile.PlayOrPause = PLAY_STS_PLAYING;
				DispMessage |= (U32) DISP_MSG_PLAYSTATE_CHANGE;
			}
			else
			{
				/* Ignore if not release from PAUSE */
			}
			EgplaySubstate = GET_FOLDER_INFO;
		}
		else
		{
			/* Not new music */
		}
		break;
	default:
		break;
	}
#endif
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : AE1 task control
 * Include           : none
 * Declaration       : void App_Task_AE1(void)
 * Description       : AE1 task control
 *                   :     (1) Initialize AE1
 *                   :     (2) Detect connection
 *                   :     (3) Playback/Pause
 *                   :     (4) FF/FR
 *                   :     (5) Get device information(file/folder number)
 *                   :     (6) Get AE1 version
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
#if 0
void App_Task_AE1(void)
{
	BackupTaskReturnAddr();
	/* !! Auto variable must not used here, because we have used the TaskWait() */
	/* *** 1. Interface layer process *** */
	IF_AE1Ctrl_ComPro(); /* Transmit and receive progress */

	/* *** 2. AE1 application task process *** */
	if (EgAE1Task != AE1_POWER_DOWN)
	{
		RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
		if (EgCSI0ComState == STS_RECEPTION_OVER)
		{
			if (*TaskRecallEvent == TaskRecallValue)
			{
				/* NOTE: depends on MCU RAM area! */CANCEL_EVENT();
				/* NOTE: depends on MCU RAM area! */TASK_RECALL();
			}
			else
			{
				/* Reception over but is spontaneous STS */
			}

			/* SPONTANEOUS status command */
			if (RecCmd->Counter >= (U8) 0x80)
			{
				switch (RecCmd->Identify)
				{
				case STS_NO_RESPONSE:
					/* Ignore */
					break;
				case STS_USB_SD_CONNECTION:
					/* Connection/file status changed */
					SaveSponSTS_UsbSdConnect();
					break;
				case STS_CONNECTION_STATUS:
					/* Plug/Pull status */
					SaveSponSTS_Connect();
					break;
				case STS_PLAYBACK_PAUSE:
					/* Update music info */
					SaveSponSTS_PlaybackPause();
					break;
				case STS_FF_FR:
					/* Update music info */
					break;
				case STS_ISOCHRONOUS_ERROR:
					/* Reset */
					break;
				case STS_IAP_COMMUNICATION:
					/* Get the status and content */
					break;
				case STS_TIME_INFO:
					/* Time info update */
					SaveSponSTS_TimeInfo();
					break;
				default:
					/* Not-defined command */
					break;
				}
			}
			else
			{
				/* AE1 send command sequence error */
#ifdef DEBUG_ON
				Service_Error_PrintInfo("ErrSTSIDRxed"); /* Setting error process */
#endif
			}
		}
		else
		{
			/* Continue if no STS received */
		}

		if ((EgCSI0ComState != AE1_IF_IDLE) && (EgCSI0ComState != WAIT_COM)
				&& (EgCSI0ComState != STS_RECEPTION_OVER))
		{
			/* Return at once if the command is waiting for process */
			return;
#if 0
			/////CHECK OVERTIME
			/* Please refer page 105 of UM Rev.0.80
			 * There exists that maybe take more time. */
			if(IsGuardTmrTimeout(, GUARDTIME_CMD2STS) == TRUE)
			{
				/* If wait STS overtime then process exception */
				EgAE1Task = AE1_TASK_EXECEPTION;
			}
			else
			{
				/* Keep waiting */
				return;
			}
#endif
		}
		else
		{
		}

		if (EVENT_EXIST())/* NOTE: depends on MCU RAM area! */
		{
			/* Return if the command is waiting for response */
			return;
#if 0
			/////CHECK OVERTIME
			/* Please refer page 105 of UM Rev.0.80
			 * There exists that maybe take more time. */
			if(IsGuardTmrTimeout(, GUARDTIME_CMD2STS) == TRUE)
			{
				/* If wait STS overtime then process exception */
				EgAE1Task = AE1_TASK_EXECEPTION;
			}
			else
			{
				/* Keep waiting */
				return;
			}
#endif
		}
		else
		{
		}
	}
	else
	{
		/* If AE1 task is Power-down state
		 * then process in AE1 task state machine below. */
	}

	/* AE1 control state machine */
	switch (EgAE1Task)
	{
	case AE1_POWER_DOWN:
		UpdateAE1MsgForDisp_Disconnected();
		if (IsPowerUp())
		{
			/* Restore state */
			EgAE1Task = INIT_AE1;
		}
		break;
	case INIT_AE1:
		/* Initialize - Default settings */
		sendCmd_DefaultSetting();
		TaskRecallEvent = U8AE1ComRxBuf;
		TaskRecallValue = U8gcmdCounter;
		TaskWait();
		RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
		if (RecCmd->Status != IDD0_CDB7_SET_COMPLETED)
		{
#ifdef DEBUG_ON
			Service_Error_PrintInfo("DefaultSetErr"); /* Setting error process */
#endif
		}
		else
		{
			/* Initialize - Decoder settings */
			sendCmd_DecoderSelect();
			TaskRecallEvent = U8AE1ComRxBuf;
			TaskRecallValue = U8gcmdCounter;
			TaskWait();
			RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
			if (RecCmd->Status != IDC1_STS_SETUP_COMPLETED)
			{
#ifdef DEBUG_ON
				Service_Error_PrintInfo("DecoderSetErr"); /* Setting error process */
#endif
			}
			else
			{
				/* [Initialize - Volume adjustment] */
				attenuationValue = (U16) TEVData.S8Volume & (U16) 0x7f;
				attenuationValue = attenuationValue * (MAX_ATTENUATION_VALUE
						/ (U16) MAX_VOLUME_RANGE);
				sendCmd_OutputAdjust(attenuationValue);
				TaskRecallEvent = U8AE1ComRxBuf;
				TaskRecallValue = U8gcmdCounter;
				TaskWait();
				RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;

				/* [Initialize - Playback mode] */
				sendCmd_PlaybackMode(GetPlaybackMode(&TPlayState));
				TaskRecallEvent = U8AE1ComRxBuf;
				TaskRecallValue = U8gcmdCounter;
				TaskWait();
				RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
				UpdateAE1MsgForDisp_PlaybackMode(RecCmd->Status);

				/* [Initialize - Check AE1 firmware version] */
				sendCmd_ROMVersion();
				TaskRecallEvent = U8AE1ComRxBuf;
				TaskRecallValue = U8gcmdCounter;
				TaskWait();
				UpdateAE1MsgForDisp_ROMVersion();/* Update message for display */

				/* Initialize - USB connection */
#ifdef FIRM_VER_080_USED
				sendCmd_USBSDConnection(START_DETECT_CONNECTION);
#else
				sendCmd_USBSDConnection(USB_CONNECTION_START);
#endif
				TaskRecallEvent = U8AE1ComRxBuf;
				TaskRecallValue = U8gcmdCounter;
				TaskWait();
				RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
				if (RecCmd->Status == ID80CDB7_CASE_CMD_NOT_EXED)
				{
#ifdef DEBUG_ON
					Service_Error_PrintInfo("ConnectionSetErr"); /* Setting error process */
#endif
				}
				else
				{
#ifdef FIRM_VER_080_USED
					/* Clear current media status */
					ClearMediaConnectInfo_USB();
#ifdef SD_USED
					ClearMediaConnectInfo_SD();
#endif
					StartCounter(&U32gAE1ConnectGuardTimer);
					/* Print message for waiting connection */
					DispMessage |= DISP_MSG_WARN_NOMEDIA;
					EgAE1Task = DEV_DISCONNECTED;
#else/* If not define firmware ver.0.80 */
#ifdef SD_USED
					/* Initialize - SD connection */
					sendCmd_USBSDConnection(SD_CONNECTION_START);
					TaskRecallEvent = U8AE1ComRxBuf;
					TaskRecallValue = U8gcmdCounter;
					TaskWait();
					RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
					if (RecCmd->Status == ID80CDB7_CASE_CMD_NOT_EXED)
					{
#ifdef DEBUG_ON
						Service_Error_PrintInfo("ConnectionSetErr"); /* Setting error process */
#endif
					}
					else
#endif
					{
						/* Clear current media status */
						ClearMediaConnectInfo_USB();
#ifdef SD_USED
						ClearMediaConnectInfo_SD();
#endif
						StartCounter(&U32gAE1ConnectGuardTimer);
						/* Print message for waiting connection */
						DispMessage |= DISP_MSG_WARN_NOMEDIA;
						EgAE1Task = DEV_DISCONNECTED;

					}/* Initialize - SD connection End */
#endif/* End of not define firmware ver.0.80 */
				}/* Initialize - USB connection End */
			}/* Initialize - Decoder settings End */
		}/* Initialize - Default settings End */
		break;
	case DEV_DISCONNECTED:
		/* **** Process host message Start **** */
		switch (GetAndClearMsgFromHost())
		{
		case AE1_MSG_NULL:
			break;
		case AE1_MSG_PLAY_PAUSE:
			/* Invalid */
			break;
		case AE1_MSG_SHIFT_REPEAT:
		case AE1_MSG_RANDOM_SEQUENCE:
		case AE1_MSG_SCAN_NORMAL:
			/* Playback mode */
			sendCmd_PlaybackMode(GetPlaybackMode(&TPlayState));
			TaskRecallEvent = U8AE1ComRxBuf;
			TaskRecallValue = U8gcmdCounter;
			TaskWait();
			RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;

			UpdateAE1MsgForDisp_PlaybackMode(RecCmd->Status);
			break;
		case AE1_MSG_SHIFT_MEDIA:
			/* Invalid */
			break;
		case AE1_MSG_READ_FIRMWARE_VERSION:
			/* Invalid */
			break;
		case AE1_MSG_TEST_SDCARD:
			/* Test command */
			break;
		case AE1_MSG_TEST_USB:
			/* Test command */
			break;
		case AE1_MSG_UPDATE_FILE_INFO:
			/* Other command */
			break;
		case AE1_MSG_PERIPHERAL_POWER_UP:
			/* Power up */
			break;
		case AE1_MSG_PERIPHERAL_POWER_DOWN:
			/* Power down */
			needPowerDown = TRUE;
			break;
		case AE1_MSG_PERIPHERAL_RESET:
			/* Invalid */
			break;
		case AE1_MSG_UPDATE_VOLUME:
			/* Volume adjustment, ignore */
			break;
		default:
			/* Other message then do nothing */
			break;
		}

		/* Check Power-off */
		if ((needPowerDown == TRUE) && (EgCSI0ComState == WAIT_COM))
		{
			/* It is not necessary to clear display information */

			/* Note:
			 * Current playback information are saved in real time */

			/* After communication is over then transfer state */
			needPowerDown = FALSE;
			EgAE1Task = AE1_POWER_DOWN;
			break;
		}/* **** Process host message end **** */
		else
		{
			/* If not Power-Down then continue */

			/* **** Process spontaneous STS Start **** */
			/* (1) Mark current connected media status */
			/* Check connection: 83H */
			if (IsConnected())
			{
				/* Connected is detected */
				if ((stsConnectStatus.usbConnectInfo == USB_CONNECTION_DETECTED)
						|| (stsConnectStatus.usbConnectInfo
								== USB_CON_DETECTED_STS_CHANGED))
				{
					currentMediaStatus.usb.connectSts = CONNECTED;
					if (TPlayState.U8Media == MEDIA_TYPE_INVALID)
					{
						TPlayState.U8Media = MEDIA_TYPE_USB;
					}
					UpdateAE1MsgForDisp_UsbConnected();
				}
#ifdef SD_USED
				if ((stsConnectStatus.sdConnectInfo == SD_CONNECTION_DETECTED)
						|| (stsConnectStatus.sdConnectInfo
								== SD_CON_DETECTED_STS_CHANGED))
				{
					currentMediaStatus.sd.connectSts = CONNECTED;
					if (TPlayState.U8Media == MEDIA_TYPE_INVALID)
					{
						TPlayState.U8Media = MEDIA_TYPE_SD;
					}
					UpdateAE1MsgForDisp_SdConnected();
				}
#endif
				/* Print message for waiting connection */
				DispMessage |= DISP_MSG_WARN_ANYING;
			}

			/* Clear temporary information */
			ClearSponSTS_Connect();

			/* (2) If default playback media is connected then start/resume playback
			 * or else, select other connected media and start/resume playback */
			if (MediaCanBePlayed() == MEDIA_TYPE_USB)
			{
				/* If connecting media is overtime
				 * then exit connect action and update display for media disconnection
				 * and start another media connection */
				if (IsConnectMediaOvertime() == TRUE)
				{
					/* if connection overtime then connect another media */
					if (TPlayState.U8Media == MEDIA_TYPE_USB)
					{
						TPlayState.U8Media = mediaListTable[GetNextMediaNum(
								MEDIA_TYPE_USB)];
						StartCounter(&U32gAE1ConnectGuardTimer);
						ClearMediaConnectInfo_USB();
						/* Update display information */
						UpdateAE1MsgForDisp_UsbDisconnected();
					}
#ifdef SD_USED
					else if (TPlayState.U8Media == MEDIA_TYPE_SD)
					{
						TPlayState.U8Media = mediaListTable[GetNextMediaNum(
								MEDIA_TYPE_SD)];
						StartCounter(&U32gAE1ConnectGuardTimer);
						ClearMediaConnectInfo_SD();
						/* Update display information */
						UpdateAE1MsgForDisp_SdDisconnected();
					}
#endif
					else
					{
						/* Ignore other media */
					}

					/* Print message for waiting connection */
					DispMessage |= DISP_MSG_WARN_NOMEDIA;
				}
				else
				{
					/* if connection not overtime then connect */
					/* A. Start USB connection */
					/* USB connection */
#ifdef FIRM_VER_080_USED
					sendCmd_USBSDConnection(POLL_USB);
#else
					sendCmd_USBSDConnection(USB_CONNECTION_START);
#endif
					TaskRecallEvent = U8AE1ComRxBuf;
					TaskRecallValue = U8gcmdCounter;
					TaskWait();
					RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
					if (RecCmd->Status == ID80CDB7_CASE_CMD_NOT_EXED)
					{
#ifdef DEBUG_ON
						Service_Error_PrintInfo("ConnectionSetErr"); /* Setting error process */
#endif
					}

					/* Save media information */
					if (pstsUsbSdConnection->connectStatus == CON_STS_CONNECTED)
					{
						saveConnectedMediaInfo_USB();

						/* B. Start playback */
						/* If can play USB media then Start/Resume */
						if ((currentMediaStatus.usb.isFileValid == FALSE)
								&& (pstsUsbSdConnection->fileSysStatus
										== FILE_STS_ANALYSIS_COMPLETED))
						{
							/* File number is 0 */
							EgAE1Task = NO_VALID_FILE;
						}
						else if (currentMediaStatus.usb.isFileValid == TRUE)
						{
							/* Start playback.
							 * NOTE: THIS FUNCTION IS INLINE FUCNTION.
							 *       AND, MAYBE TRANSFER TO "PLAYBACK" STATE. */
							GetMediaInfo_USB();
#ifdef FIRM_VER_080_USED
							/* Switch to USB media */
							sendCmd_ComSetup(MASS_STORAGE_USB);
							TaskRecallEvent = U8AE1ComRxBuf;
							TaskRecallValue = U8gcmdCounter;
							TaskWait();
							RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
							if (pstsComSetupInfo->setupStatus
									== IDDE_CDB7_SETUP_COMPLETED)
							{
								UsbPlayback();
							}
							else
							{
								/* Wait to switch media successfully */
							}
#else
							UsbPlayback();
#endif
						}/* End of "File in media is valid" */
						else
						{
							/* Wait until file system analysis complete */
						}
					}
					else if (pstsUsbSdConnection->connectStatus
							== CON_STS_WAITING_COM_SETUP)
					{
						/* A.1 Get media information */
						/* NOTE: THIS FUNCTION IS INLINE FUCNTION.
						 *       AND, MAYBE TRANSFER TO "PLAYBACK" STATE. */
						GetMediaInfo_USB();

						/* A.2 To do: Judge media type */

						/* A.3 Communication setup */
						sendCmd_ComSetup(MASS_STORAGE_USB);
						TaskRecallEvent = U8AE1ComRxBuf;
						TaskRecallValue = U8gcmdCounter;
						TaskWait();
						RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
						/* ProcessStsComSetup(RecCmd->Status); */
					}/* End of USB communication setup */
					else if (pstsUsbSdConnection->connectStatus
							== CON_STS_BEING_CONNECTED)
					{
						/* Being connected, wait */
					}
					else
					{
						/* Ignore other situation */
					}
				}/* End of connection not over time */
			}/* End of USB media playback */
#ifdef SD_USED
			else if (MediaCanBePlayed() == MEDIA_TYPE_SD)
			{
				/* If connecting media is overtime
				 * then exit connect action and update display for media disconnection
				 * and start another media connection */
				if (IsConnectMediaOvertime() == TRUE)
				{
					/* if connection overtime then connect another media */
					if (TPlayState.U8Media == MEDIA_TYPE_USB)
					{
						TPlayState.U8Media = mediaListTable[GetNextMediaNum(
								MEDIA_TYPE_USB)];
						StartCounter(&U32gAE1ConnectGuardTimer);
						ClearMediaConnectInfo_USB();
						/* Update display information */
						UpdateAE1MsgForDisp_UsbDisconnected();
					}
					else if (TPlayState.U8Media == MEDIA_TYPE_SD)
					{
						TPlayState.U8Media = mediaListTable[GetNextMediaNum(
								MEDIA_TYPE_SD)];
						StartCounter(&U32gAE1ConnectGuardTimer);
						ClearMediaConnectInfo_SD();
						/* Update display information */
						UpdateAE1MsgForDisp_SdDisconnected();
					}
					else
					{
						/* Ignore other media */
					}

					/* Print message for waiting connection */
					DispMessage |= DISP_MSG_WARN_NOMEDIA;
				}
				else
				{
					/* if connection not overtime then connect */
					/* A. Start SD connection */
#ifdef FIRM_VER_080_USED
					sendCmd_USBSDConnection(POLL_SD);
#else
					sendCmd_USBSDConnection(SD_CONNECTION_START);
#endif
					TaskRecallEvent = U8AE1ComRxBuf;
					TaskRecallValue = U8gcmdCounter;
					TaskWait();
					RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
					if (RecCmd->Status == ID80CDB7_CASE_CMD_NOT_EXED)
					{
#ifdef DEBUG_ON
						Service_Error_PrintInfo("ConnectionSetErr"); /* Setting error process */
#endif
					}

					/* Save media information */
					if (pstsUsbSdConnection->connectStatus == CON_STS_CONNECTED)
					{
						saveConnectedMediaInfo_SD();

						/* B. Start playback */
						/* If can play SD media then Start/Resume */
						if ((currentMediaStatus.sd.isFileValid == FALSE)
								&& (pstsUsbSdConnection->fileSysStatus
										== FILE_STS_ANALYSIS_COMPLETED))
						{
							/* File number is 0 */
							EgAE1Task = NO_VALID_FILE;
						}
						else if (currentMediaStatus.sd.isFileValid == TRUE)
						{
							/* Start playback.
							 * NOTE: THIS FUNCTION IS INLINE FUCNTION.
							 *       AND, MAYBE TRANSFER TO "PLAYBACK" STATE. */
							GetMediaInfo_SD();
#ifdef FIRM_VER_080_USED
							/* Switch to USB media */
							sendCmd_ComSetup(MASS_STORAGE_SD);
							TaskRecallEvent = U8AE1ComRxBuf;
							TaskRecallValue = U8gcmdCounter;
							TaskWait();
							RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
							if (pstsComSetupInfo->setupStatus
									== IDDE_CDB7_SETUP_COMPLETED)
							{
								SdPlayback();
							}
							else
							{
								/* Wait to switch media successfully */
							}
#else
							SdPlayback();
#endif
						}/* End of "File in media is valid" */
						else
						{
							/* Wait until file system analysis complete */
						}
					}
					else if (pstsUsbSdConnection->connectStatus
							== CON_STS_WAITING_COM_SETUP)
					{
						/* A.1 Get media information */
						/* NOTE: THIS FUNCTION IS INLINE FUCNTION.
						 *       AND, MAYBE TRANSFER TO "PLAYBACK" STATE. */
						GetMediaInfo_SD();

						/* A.2 To do: Judge media type */

						/* A.3 Communication setup */
						sendCmd_ComSetup(MASS_STORAGE_SD);
						TaskRecallEvent = U8AE1ComRxBuf;
						TaskRecallValue = U8gcmdCounter;
						TaskWait();
						RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
						/* ProcessStsComSetup(RecCmd->Status); */
					}/* End of SD communication setup */
					else if (pstsUsbSdConnection->connectStatus
							== CON_STS_BEING_CONNECTED)
					{
						/* Being connected, wait */
					}
					else
					{
						/* Ignore other situation */
					}
				}/* End of connection not over time */
			}/* End of SD media playback */
#endif
			else
			{
				/* Ignore to check other media except USB & SD */
			}/* End of other media playback */
			/* **** Process spontaneous STS End **** */
		}/* End of Process for not Power-Down */

		break;
	case PLAYBACK:
		/* **** Process host message Start **** */
		switch (GetAndClearMsgFromHost())
		{
		case AE1_MSG_NULL:
			break;
		case AE1_MSG_PLAY_PAUSE:
			/* Playback <-> Pause */
			if (AE1MsgForDisplay.currentFile.PlayOrPause == PLAY_STS_PLAYING)
			{
				/* Paused */
				cmdPlaybackPausePara.specifiedFileOrFolderNum = 0x0000;
				setPlaybackParas_Zero();
				sendCmd_PlaybackPause(PAUSE_STOP, &cmdPlaybackPausePara);
				TaskRecallEvent = U8AE1ComRxBuf;
				TaskRecallValue = U8gcmdCounter;
				TaskWait();
				RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
				if (RecCmd->Status == ID90_CASE_CMD_NOT_EXED)
				{

#ifdef DEBUG_ON
					Service_Error_PrintInfo("PlayPauseCmdErr"); /* Setting error process */
#endif
				}
				else
				{
					if (pstsPlayback_Pause->playStatus
							== PLAY_STS_PLAYBACK_PAUSED)
					{
						/* Paused */
						UpdateAE1MsgForDisp_Paused();
						/* Inform host to start SwitchFile or SwitchFolder count */
						TPlayState.U8Pause = OFF;
					}
					else
					{
						/* Not paused */
					}
				}/* End of command was executed */
			}/* End of PLAYBACK -> AUSE */
			else if (AE1MsgForDisplay.currentFile.PlayOrPause == PLAY_STS_PAUSE)
			{
				/* Playback or Pause released */
				cmdPlaybackPausePara.specifiedFileOrFolderNum = 0x0000;
				setPlaybackParas_Zero();
				sendCmd_PlaybackPause(PAUSE_RELEASED, &cmdPlaybackPausePara);
				TaskRecallEvent = U8AE1ComRxBuf;
				TaskRecallValue = U8gcmdCounter;
				TaskWait();
				RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
				if (RecCmd->Status == ID90_CASE_CMD_NOT_EXED)
				{
#ifdef DEBUG_ON
					Service_Error_PrintInfo("PlayPauseCmdErr"); /* Setting error process */
#endif
				}
				else
				{
					if (pstsPlayback_Pause->playStatus
							== PLAY_STS_PLAYBACK_STARTED)
					{
						/* Playback started */
						UpdateAE1MsgForDisp_StartPlay();
					}
					else
					{
						/* Not playback started then re-send command */
					}
				}/* End of command was executed */
			}/* End of PAUSE -> PLAYBACK */
			else
			{
				/* Not (Playback & Pause) then idle */
			}

			break;
		case AE1_MSG_SHIFT_REPEAT:
		case AE1_MSG_RANDOM_SEQUENCE:
		case AE1_MSG_SCAN_NORMAL:
			/* Playback mode */
			/* Switch mode */
			sendCmd_PlaybackMode(GetPlaybackMode(&TPlayState));
			TaskRecallEvent = U8AE1ComRxBuf;
			TaskRecallValue = U8gcmdCounter;
			TaskWait();
			RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;

			UpdateAE1MsgForDisp_PlaybackMode(RecCmd->Status);

			/* if scan is enabled then switch to next file at once */
			if (TPlayState.U8EnableScan == ON)
			{
				/* Scan is enabled then
				 * Switch to next music directly(10H) */
				/* Send command to switch next */
				cmdPlaybackPausePara.specifiedFileOrFolderNum = (U16) 0x0000;
				setPlaybackParas_Zero();
				sendCmd_PlaybackPause(PLAY_FROM_NEXT_START,
						&cmdPlaybackPausePara);
				TaskRecallEvent = U8AE1ComRxBuf;
				TaskRecallValue = U8gcmdCounter;
				TaskWait();
				RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
				if (RecCmd->Status == ID90_CASE_CMD_NOT_EXED)
				{
#ifdef DEBUG_ON
					Service_Error_PrintInfo("ToSpeci.fileErr"); /* Setting error process */
#endif
				}
				else
				{
					/* Music changed then save music file number */
					if (pstsPlayback_Pause->playStatus
							== PLAY_STS_PLAYBACK_STARTED)
					{
						updateCurrentPlayInfo();
					}
					else
					{
						/* Not playback then need to re-send command */
					}
				}/* End of command was executed */
			}/* End of "scan is enabled" */
			else
			{
				/* continue if scan is disabled */
			}
			break;
		case AE1_MSG_SHIFT_MEDIA:
			/* Switch media */
			SwitchMedia();
			break;
		case AE1_MSG_READ_FIRMWARE_VERSION:
			/* Invalid */
			break;
		case AE1_MSG_TEST_SDCARD:
			/* Test command */
			break;
		case AE1_MSG_TEST_USB:
			/* Test command */
			break;
		case AE1_MSG_UPDATE_FILE_INFO:
			break;
		case AE1_MSG_PERIPHERAL_POWER_UP:
			break;
		case AE1_MSG_PERIPHERAL_POWER_DOWN:
			/* Power off */
			needPowerDown = TRUE;
			break;
		case AE1_MSG_PERIPHERAL_RESET:
			break;
		case AE1_MSG_UPDATE_VOLUME:
			/* Volume adjustment */
			attenuationValue = (U16) TEVData.S8Volume & (U16) 0x7f;
			attenuationValue = attenuationValue * (MAX_ATTENUATION_VALUE
					/ (U16) MAX_VOLUME_RANGE);
			sendCmd_OutputAdjust(attenuationValue);
			TaskRecallEvent = U8AE1ComRxBuf;
			TaskRecallValue = U8gcmdCounter;
			TaskWait();
			RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
			break;
		default:
			/* Other message then do nothing */
			break;
		}

		/* Check Power-off */
		if ((needPowerDown == TRUE) && (EgCSI0ComState == WAIT_COM))
		{
			/* It is not necessary to clear display information */

			/* Note:
			 * Current playback information are saved in real time */

			/* After communication is over then transfer state */
			needPowerDown = FALSE;
			EgAE1Task = AE1_POWER_DOWN;
			break;
		}/* **** Process host message End **** */
		else if (EgAE1Task != DEV_DISCONNECTED)
		{
			/* If not Power-Down then continue */

			/* *** Switch Folder or File Start *** */
			/* 1. Switch Folder */
			if (isFolderInfoComplete == TRUE)
			{
				/* If get folder information is complete then can switch folder */
				if (TMsgHostToAE1.S8HostToAE1FolderCount != (S8) 0)
				{
					/* Adjust number */
					/* Calculate target folder number based on current folder number
					 *   target folder number = current folder number + variable folder number */
					switchFolderNum = TMsgHostToAE1.S8HostToAE1FolderCount
							+ (S16) currentPlayInfo.currentFolderNum;
					/* Clear count */
					TMsgHostToAE1.S8HostToAE1FolderCount = (S8) 0;

					if (switchFolderNum
							> (S16) currentPlayInfo.currentFolderNum)
					{
						/* If target folder number > current folder number
						 * then judge whether switch or not */
						if (currentPlayInfo.currentFolderNum
								== (currentPlayInfo.resumeInfo.totalFolderNum
										+ ((U16) ROOT_FOLDER_NUM - (U16) 1)))
						{
							/* If current folder is the last folder then do noting */
							switchFolderNum
									= (S16) (currentPlayInfo.currentFolderNum);
							getFolderInfoCtl = KEEP_SILENT;
						}
						else
						{
							/* If current folder != the last folder then
							 *   target folder number = current folder number + 1
							 *   folderSwitchDirection = clockWise */
							switchFolderNum
									= (S16) currentPlayInfo.currentFolderNum
											+ (S16) 1;
							getFolderInfoCtl = CLOCKWISE;
						}
					}/* End of switch folder number > current folder number */
					else
					{
						/* If target folder number < current folder number
						 * then judge whether switch or not */
						if (currentPlayInfo.currentFolderNum
								== (U16) ROOT_FOLDER_NUM)
						{
							/* If current folder is the last folder then do noting */
							switchFolderNum
									= (S16) currentPlayInfo.currentFolderNum;
							getFolderInfoCtl = KEEP_SILENT;
						}
						else
						{
							/* If current folder != the root folder then
							 *   target folder number = current folder number - 1
							 *   folderSwitchDirection = antiClockWise */
							switchFolderNum
									= (S16) currentPlayInfo.currentFolderNum
											- (S16) 1;
							getFolderInfoCtl = ANTI_CLOCKWISE;
						}
					}/* End of switch folder number < current folder number */

					if (switchFolderNum
							== (S16) currentPlayInfo.currentFolderNum)
					{
						/* If current folder is the last folder and want to switch higher folder
						 *  then do nothing */
						/* If current folder is the 1st folder and want to switch lower folder
						 *  then do nothing */
					}
					else
					{

						/* If current folder is not the last folder then send command to switch */
						/* Send command to switch music */
						cmdPlaybackPausePara.specifiedFileOrFolderNum
								= (U16) switchFolderNum;
						setPlaybackParas_Zero();
						sendCmd_PlaybackPause(PLAY_DIRECT_FOLDER,
								&cmdPlaybackPausePara);
						TaskRecallEvent = U8AE1ComRxBuf;
						TaskRecallValue = U8gcmdCounter;
						TaskWait();
						RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
						if (RecCmd->Status == ID90_CASE_CMD_NOT_EXED)
						{
#ifdef DEBUG_ON
							Service_Error_PrintInfo("ToSpeci.folderErr"); /* Setting error process */
#endif
						}
						else
						{
							/* Music changed then save music file number */
							if (pstsPlayback_Pause->playStatus
									== PLAY_STS_PLAYBACK_STARTED)
							{
								currentPlayInfo.currentFolderNum
										= ReadU16FromBuf(
												(U8*) &(pstsPlayback_Pause->subjectFolderNum));
								currentPlayInfo.resumeInfo.fileNum
										= ReadU16FromBuf(
												(U8*) &(pstsPlayback_Pause->fileNum));
								/* Update display information */
								UpdateAE1MsgForDisp_NewFile();
								UpdateAE1MsgForDisp_ClearPlaytime();

								/* Save resume information */
								SaveResumeInfo(
										currentPlayInfo.resumeInfo.deviceType);

								/* Is Folder Information Complete */
								isFolderInfoComplete = FALSE;
							}/* End of playback started */
							else if (pstsPlayback_Pause->playStatus
									== PLAY_STS_FILENUM_ZERO)
							{
								/* If file number in folder is 0 then switch to next folder.
								 * This is only happened when CMD(00H)'s CDB8=00H. */
								switchFolderNum = switchFolderNum + (S16) 1;
								/* Send command to switch music */
								cmdPlaybackPausePara.specifiedFileOrFolderNum
										= (U16) switchFolderNum;
								setPlaybackParas_Zero();
								sendCmd_PlaybackPause(PLAY_DIRECT_FOLDER,
										&cmdPlaybackPausePara);
								TaskRecallEvent = U8AE1ComRxBuf;
								TaskRecallValue = U8gcmdCounter;
								TaskWait();
								RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
								if (RecCmd->Status == ID90_CASE_CMD_NOT_EXED)
								{
#ifdef DEBUG_ON
									Service_Error_PrintInfo("ToSpeci.folderErr"); /* Setting error process */
#endif
								}
								else
								{
									/* Music changed then save music file number */
									if (pstsPlayback_Pause->playStatus
											== PLAY_STS_PLAYBACK_STARTED)
									{
										currentPlayInfo.currentFolderNum
												= ReadU16FromBuf(
														(U8*) &(pstsPlayback_Pause->subjectFolderNum));
										currentPlayInfo.resumeInfo.fileNum
												= ReadU16FromBuf(
														(U8*) &(pstsPlayback_Pause->fileNum));
										/* Update display information */
										UpdateAE1MsgForDisp_NewFile();
										UpdateAE1MsgForDisp_ClearPlaytime();

										/* Save resume information */
										SaveResumeInfo(
												currentPlayInfo.resumeInfo.deviceType);

										/* Is Folder Information Complete */
										isFolderInfoComplete = FALSE;
									}
									else
									{
										/* Not playback then need to re-send command */
									}
								}/* End of command was executed */
							}/* End of "if target folder total file number is 0" */
							else
							{
								/* Ignore other parameters */
							}
						}/* End of command was executed */
					}/* End of can switch folder */
				}/* End of Switch folder */
			}/* End of send command (switch folder) */
			else
			{
				/* If get folder information is not complete then not switch folder */
			}

			/* 2. Switch File */
			/* 2.1 if current file is invalid file type then switch to next file */
			if ((IsGuardTmrTimeout(U16gMonitorPlayTime, PLAYBACK_TIME_MONITOR)
					== TRUE) && (AE1MsgForDisplay.currentFile.PlayOrPause
					== PLAY_STS_PLAYING))
			{
				if (prevPlaybackTime == newPlaybackTime)
				{
					/* Send command to switch next */
					cmdPlaybackPausePara.specifiedFileOrFolderNum
							= (U16) 0x0000;
					setPlaybackParas_Zero();
					sendCmd_PlaybackPause(PLAY_FROM_NEXT_START,
							&cmdPlaybackPausePara);
					TaskRecallEvent = U8AE1ComRxBuf;
					TaskRecallValue = U8gcmdCounter;
					TaskWait();
					RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
					if (RecCmd->Status == ID90_CASE_CMD_NOT_EXED)
					{
#ifdef DEBUG_ON
						Service_Error_PrintInfo("ToSpeci.fileErr"); /* Setting error process */
#endif
					}
					else
					{
						/* Music changed then save music file number */
						if (pstsPlayback_Pause->playStatus
								== PLAY_STS_PLAYBACK_STARTED)
						{
							updateCurrentPlayInfo();

						}
						else
						{
							/* Not playback then need to re-send command */
						}
					}/* End of command was executed */
				}/* End of invalid file playback overtime by specified time */
				else
				{
					prevPlaybackTime = newPlaybackTime;
				}
				StartGuardTimer(&U16gMonitorPlayTime);
			}
			else
			{
				/* Wait for re-get */
			}
			/* 2.2 If folder is changed by switch file then ignore switching file */
			if (isFolderInfoComplete == TRUE)
			{
				/* If folder information have been gotten then can switch file */
				if (TMsgHostToAE1.S8HostToAE1FileCount != (S8) 0)
				{
					/* Adjust number */
					switchFileNum = TMsgHostToAE1.S8HostToAE1FileCount
							+ (S32) currentPlayInfo.resumeInfo.fileNum;
					/* Clear count */
					TMsgHostToAE1.S8HostToAE1FileCount = 0;
					if (switchFileNum
							> (S32) currentPlayInfo.resumeInfo.totalFileNum)
					{
						/* If over-range then switch to last file */
						switchFileNum
								= (S32) currentPlayInfo.resumeInfo.totalFileNum;
					}
					else if (switchFileNum < (S32) 1)
					{
						/* If under-range then switch to the 1st file */
						switchFileNum = (S32) 1;
					}
					else
					{
						/* If not over-range then do nothing */
					}

					if (((switchFileNum
							== (S32) currentPlayInfo.resumeInfo.totalFileNum)
							&& (currentPlayInfo.resumeInfo.fileNum
									== currentPlayInfo.resumeInfo.totalFileNum))
							|| ((switchFileNum == (S32) 1)
									&& (currentPlayInfo.resumeInfo.fileNum
											== (U16) 1)))
					{
						/* If current is the last file and want to switch higher file
						 *  then do nothing */
						/* If current is the 1st file and want to switch lower file
						 *  then do nothing */
					}
					else
					{
						/* If current is not the last file then send command to switch */
						/* Send command to switch */
						cmdPlaybackPausePara.specifiedFileOrFolderNum
								= (U16) switchFileNum;
						setPlaybackParas_Zero();
						sendCmd_PlaybackPause(RESUME_OR_DIRECT_FILE_PLAY,
								&cmdPlaybackPausePara);
						TaskRecallEvent = U8AE1ComRxBuf;
						TaskRecallValue = U8gcmdCounter;
						TaskWait();
						RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;
						if (RecCmd->Status == ID90_CASE_CMD_NOT_EXED)
						{
#ifdef DEBUG_ON
							Service_Error_PrintInfo("ToSpeci.fileErr"); /* Setting error process */
#endif
						}
						else
						{
							/* Music changed then save music file number */
							if (pstsPlayback_Pause->playStatus
									== PLAY_STS_PLAYBACK_STARTED)
							{
								/* Check whether folder is changed */
								currentNewFolderNum
										= ReadU16FromBuf(
												(U8*) &(pstsPlayback_Pause->subjectFolderNum));
								if (currentNewFolderNum
										> currentPlayInfo.currentFolderNum)
								{
									/* Is Folder Information Complete */
									isFolderInfoComplete = FALSE;
									getFolderInfoCtl = CLOCKWISE;
								}
								else if (currentNewFolderNum
										< currentPlayInfo.currentFolderNum)
								{
									/* Is Folder Information Complete */
									isFolderInfoComplete = FALSE;
									getFolderInfoCtl = ANTI_CLOCKWISE;
								}
								else
								{
									getFolderInfoCtl = KEEP_SILENT;
								}
								currentPlayInfo.currentFolderNum
										= currentNewFolderNum;
								currentPlayInfo.resumeInfo.fileNum
										= ReadU16FromBuf(
												(U8*) &(pstsPlayback_Pause->fileNum));
								/* Update display information */
								UpdateAE1MsgForDisp_NewFile();
								UpdateAE1MsgForDisp_ClearPlaytime();

								/* Save resume information */
								SaveResumeInfo(
										currentPlayInfo.resumeInfo.deviceType);
							}
							else
							{
								/* Ignore other values */
								getFolderInfoCtl = getFolderInfoCtl++;
							}
						}
					}/* End of send command (music switch) */
				}/* End of Switch file */
			}/* End of send command (switch file) */
			else
			{
				/* If folder is changed by switch file then ignore switching file */
				/* If get folder information is not complete then not switch folder */
			}
			/* *** Switch Folder or File End *** */

			/* **** Process spontaneous STS Start **** */
			/* 1. Over-current detected */
			CheckOvercurrent();

			/* 2. Disconnected/Connected detected */
			CheckConnection();
			if (TPlayState.U8Media != MEDIA_TYPE_INVALID)
			{
				/* Current file device is valid then continue process */
				/* 3. "Music changed to next" */
				if (stsPlayback_Pause.playStatus == PLAY_STS_PLAYBACK_STARTED)
				{
					/* Check whether folder is changed */
					currentNewFolderNum = stsPlayback_Pause.subjectFolderNum;
					if (currentNewFolderNum > currentPlayInfo.currentFolderNum)
					{
						/* Normally, playback turn is clockwise when playback automatically */
						getFolderInfoCtl = CLOCKWISE;
					}
					else if (currentNewFolderNum
							< currentPlayInfo.currentFolderNum)
					{
						/* When repeat/random playback to the end automatically, should re-get information  */
						getFolderInfoCtl = UPSIDE;
					}
					else
					{
						getFolderInfoCtl = KEEP_SILENT;
					}
					currentPlayInfo.currentFolderNum = currentNewFolderNum;
					currentPlayInfo.resumeInfo.fileNum
							= stsPlayback_Pause.fileNum;
					/* Update current file information */
					UpdateAE1MsgForDisp_NewFile();
					UpdateAE1MsgForDisp_ClearPlaytime();

					/* Save resume information */
					SaveResumeInfo(currentPlayInfo.resumeInfo.deviceType);

					/* Clear playback information */
					ClearSponSTS_PlaybackPause();
				}
				else if (stsPlayback_Pause.playStatus == PLAY_STS_PLAYBACK_OVER)
				{
					/* Terminated for range end */
					UpdateAE1MsgForDisp_Paused();

					/* Clear playback information */
					ClearSponSTS_PlaybackPause();
				}
				else
				{
					/* Ignore pause and abnormal status */
				}

				/* **** Polling information Start **** */
				/* Music is being played */
				/* 1. Time detected */
#ifdef TIME_INFO_STS_ENABLED
				/* If time information STS spontaneously enabled
				 * process spontaneous time STS */
				if (stsTimeInfo.getResult == IDB3_TIME_GOTTEN)
				{
					/* Save current playback information - time */
					currentPlayInfo.resumeInfo.timeInfo.hour = stsTimeInfo.hour;
					currentPlayInfo.resumeInfo.timeInfo.minute
							= stsTimeInfo.minute;
					currentPlayInfo.resumeInfo.timeInfo.second
							= stsTimeInfo.second;

					/* Save resume information */
					SaveResumeInfo(currentPlayInfo.resumeInfo.deviceType);

					/* Update playback time information */
					UpdateAE1MsgForDisp_Playtime();

					/* Save playback time for judge invalid file type */
					newPlaybackTime++;
				}
				else if (stsTimeInfo.getResult == IDB3_TOTAL_TIME_GOTTEN)
				{
					/* Update total playback time information */
					AE1MsgForDisplay.currentFile.totalPlaybackTimeInSecond
							= (U32) stsTimeInfo.hour * (U32) 60;
					AE1MsgForDisplay.currentFile.totalPlaybackTimeInSecond
							= AE1MsgForDisplay.currentFile.totalPlaybackTimeInSecond
									+ (U32) stsTimeInfo.minute;
					AE1MsgForDisplay.currentFile.totalPlaybackTimeInSecond
							= AE1MsgForDisplay.currentFile.totalPlaybackTimeInSecond
									* (U32) 60;
					AE1MsgForDisplay.currentFile.totalPlaybackTimeInSecond
							= AE1MsgForDisplay.currentFile.totalPlaybackTimeInSecond
									+ stsTimeInfo.second;
					DispMessage |= (U32) DISP_MSG_PLAYTIMER_CHANGE;
				}
				else
				{
					/* Ignore other parameters */
				}
				/* Clear time information */
				ClearSponSTS_TimeInfo();
#else
				/* If time information STS spontaneously disabled
				 * send Get time information then check time information */
				if (IsGuardTmrTimeout(U16gDelayInCycle, DELAY_SEND_CMD_IN_CYCLE) == TRUE)
				{
					sendCmd_TimeInfo(TARGET_PLAYBACK_TIME);
					TaskRecallEvent = U8AE1ComRxBuf;
					TaskRecallValue = U8gcmdCounter;
					TaskWait();
					RecCmd = (typeCmdHeader *)U8AE1ComRxBuf;
					if(RecCmd->Status == IDB3CDB7_GOTTEN_DISABLED)
					{
#ifdef DEBUG_ON
						Service_Error_PrintInfo("GetTimeInfoErr"); /* Setting error process */
#endif
					}
					else
					{
						if(stsTimeInfo.getResult == IDB3_TIME_GOTTEN)
						{
							/* Save current playback information - time */
							currentPlayInfo.resumeInfo.timeInfo.hour = stsTimeInfo.hour;
							currentPlayInfo.resumeInfo.timeInfo.minute = stsTimeInfo.minute;
							currentPlayInfo.resumeInfo.timeInfo.second = stsTimeInfo.second;

							/* Save resume information */
							SaveResumeInfo(currentPlayInfo.resumeInfo.deviceType);

							/* Update playback time information */
							UpdateAE1MsgForDisp_Playtime();

							/* Save playback time for judge invalid file type */
							newPlaybackTime++;

							/* Delay in cycle */
							StartGuardTimer(&U16gDelayInCycle);
						}
						else
						{
							/* If time is not gotten then not update */
						}
					}
				}
				else
				{
					/* Wait until can get playback time information */
				}
#endif
				GetMusicInfo();
				/* **** Polling information End **** */
			}
			else
			{
				/* Current file device is invalid then do nothing */
			}
			/* **** Process spontaneous STS End **** */
		}/* End of Process for not Power-Down */
		else
		{
			/* Switch to DISCONNECTION state */
		}

		break;
	case NO_VALID_FILE:
		/* **** Process host message Start **** */
		switch (GetAndClearMsgFromHost())
		{
		case AE1_MSG_NULL:
			break;
		case AE1_MSG_PLAY_PAUSE:
			/* Invalid */
			break;
		case AE1_MSG_SHIFT_REPEAT:
		case AE1_MSG_RANDOM_SEQUENCE:
		case AE1_MSG_SCAN_NORMAL:
			/* Playback mode */
			sendCmd_PlaybackMode(GetPlaybackMode(&TPlayState));
			TaskRecallEvent = U8AE1ComRxBuf;
			TaskRecallValue = U8gcmdCounter;
			TaskWait();
			RecCmd = (typeCmdHeader *) U8AE1ComRxBuf;

			UpdateAE1MsgForDisp_PlaybackMode(RecCmd->Status);
			break;
		case AE1_MSG_SHIFT_MEDIA:
			/* Switch media */
			SwitchMedia();
			break;
		case AE1_MSG_READ_FIRMWARE_VERSION:
			/* Invalid */
			break;
		case AE1_MSG_TEST_SDCARD:
			/* Test command */
			break;
		case AE1_MSG_TEST_USB:
			/* Test command */
			break;
		case AE1_MSG_UPDATE_FILE_INFO:
			/* Invalid */
			break;
		case AE1_MSG_PERIPHERAL_POWER_UP:
			break;
		case AE1_MSG_PERIPHERAL_POWER_DOWN:
			/* Power off */
			needPowerDown = TRUE;
			break;
		case AE1_MSG_PERIPHERAL_RESET:
			break;
		case AE1_MSG_UPDATE_VOLUME:
			/* Volume adjustment, ignore */
			break;
		default:
			/* Other message then do nothing */
			break;
		}

		/* Check Power-off */
		if ((needPowerDown == TRUE) && (EgCSI0ComState == WAIT_COM))
		{
			/* It is not necessary to clear display information */

			/* Note:
			 * Current playback information are saved in real time */

			/* After communication is over then transfer state */
			needPowerDown = FALSE;
			EgAE1Task = AE1_POWER_DOWN;
			break;
		}/* **** Process host message end **** */
		else
		{
			/* If not Power-Down then continue */

			/* **** Process spontaneous STS Start **** */
			/* 1. Over-current detected */
			CheckOvercurrent();

			/* 2. Disconnected/Connected detected */
			CheckConnection();
			/* **** Process spontaneous STS End **** */
		}/* End of Process for not Power-Down */

		break;
	case AE1_TASK_EXECEPTION:
		/* AE1 task exception process
		 * e.g. AE1 wait STS overtime(hardware error). */
#ifdef DEBUG_ON
		Service_Error_PrintInfo("HWErr!"); /* Setting error process */
#endif
		break;
	default:
		break;
	}
}
#endif
/* End of file */
