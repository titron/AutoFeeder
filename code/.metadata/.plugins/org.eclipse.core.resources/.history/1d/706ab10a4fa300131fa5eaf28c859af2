/*****************************************************************************
 * DISCLAIMER
 *
 * This software is supplied by Renesas Electronics Corporation and is only
 * intended for use with Renesas products. No other uses are authorized.
 * This software is owned by Renesas Electronics Corporation and is protected
 * under all applicable laws, including copyright laws.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES
 * REGARDING THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY,
 * INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NON-INFRINGEMENT.  ALL SUCH WARRANTIES ARE EXPRESSLY
 * DISCLAIMED.
 *
 * TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
 * ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
 * FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES
 * FOR ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS
 * AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 *
 * Renesas reserves the right, without notice, to make changes to this
 * software and to discontinue the availability of this software.
 * By using this software, you agree to the additional terms and
 * conditions found by accessing the following link:
 * http://www.renesas.com/disclaimer
 *****************************************************************************/
/* Copyright (C) 2010 Renesas Electronics Corporation. All rights reserved.  */
/*****************************************************************************
 * System Name  : AE1-LF Car Audio Demo
 * File Name    : app_ae1.c
 * Abstract     : application for AE1-L.
 * Version      : 1.00
 * Device       : R8C/2A group, or R8C/2B group, or 78K0 group
 * Tool-Chain   : High-performance Embedded Workshop (Version 4.08.00.011)
 *              : Renesas M16C Standard Toolchain (V5.45.01)
 * OS           : none
 * H/W Platform : AE1-LF demo board
 * Description  : AE1-L communication code.
 *              :   send command;
 *              :   status process;
 *              :   initialize AE1-L;
 *              :   USB/SD plug & play
 *              :   play back
 * Operation    : none
 * Limitation   : This file can be only used as sample code for AE1-LF.
 *****************************************************************************
 * History      : May.15,2011 Ver. 1.00 First Release
 *****************************************************************************/

/*****************************************************************************
 Includes   <System Includes> , "Project Includes"
 *****************************************************************************/
#include "app_ae1.h"
#include "app_host.h"
#include "disp_widget.h"
#include "mcu_depend.h"
#include "app_evolume.h"/* Adjust volume */
#include "service_general.h"
/*****************************************************************************
 Typedef definitions
 *****************************************************************************/

/*****************************************************************************
 Macro definitions
 *****************************************************************************/
/* **** Initialize AE1 default settings definition **** */
/* ID = 00H */
#define ID00_CDB7_DETECT_USB          (U8)0x01/* CDB[7], Startup status */
#define ID00_CDB8_FILE_ORDER          (U8)0x00/* CDB[8], File system storage order */
#define ID00_CDB8_FOLDER_ORDER        (U8)0x40/* CDB[8], File system storage order */
#ifdef FIRM_VER_080_USED
#else
#define ID00_CDB8_FOLDER_ORDER_SORT   (U8)0x41/* CDB[8], File system storage order */
#endif
/* ID = 41H */
#define ID41_CDB7_USED_DECODER        (U8)0x00/* CDB[7], used decoder: MP3 */
/* ID = 50H */
#define ID50_CDB7_DAC_SELECT          (U8)0x01/* CDB[7], DAC selection */
#define ID50_CDB8_DAC_FORMAT          (U8)0x01/* CDB[8], DAC parameter */
#define ID50_CDB9_SD_IF               (U8)0x00/* CDB[9], SD I/F */
#define ID50_CDB10_SD_IF_CLK          (U8)0x09/* CDB[10], Serial flash I/F clock */
#define ID50_CDB17_MAX_FOLDER_LEVEL   (U8)0x07/* CDB[17], max folder layer number */
#define ID50_CDB18_MAX_FILE_NUM_H     (U8)0xFF/* CDB[18], max file number,MSB */
#define ID50_CDB19_MAX_FILE_NUM_L     (U8)0xFF/* CDB[19], max file number,LSB */
#ifdef  FIRM_VER_080_USED
#define ID50_CDB20_MAX_FOLDER_NUM_H   (U8)0x07/* CDB[20], max folder number,MSB */
#define ID50_CDB21_MAX_FOLDER_NUM_L   (U8)0xD0/* CDB[21], max folder number,LSB */
#else
#define ID50_CDB20_MAX_FOLDER_NUM_H   (U8)0x03/* CDB[20], max folder number,MSB */
#define ID50_CDB21_MAX_FOLDER_NUM_L   (U8)0xE7/* CDB[21], max folder number,LSB */
#endif
#define ID50_CDB22_MAX_TAG_LEN_H      (U8)0x00/* CDB[22], max tag length, MSB */
#define ID50_CDB23_MAX_TAG_LEN_L      (U8)0x40/* CDB[23], max tag length, LSB */
#define ID50_CDB24_CHAR_CODE_CONVERSE (U8)0x00/* CDB[24], character code conversion */
#ifdef  FIRM_VER_080_USED
#define ID50_CDB25_LOCAL_CODE         (U8)0x00/* CDB[25], local language code */
#define ID50_CDB26_PLAY_OPTION        (U8)0x00/* CDB[26], play option */
#define ID50_CDB27_SCANTIME           (U8)0x0A/* CDB[27], scan time */
#define ID50_CDB28_STS_FRM_LEN_H      (U8)0x80/* CDB[28], max status frame length, MSB */
#define ID50_CDB29_STS_FRM_LEN_L      (U8)0xC0/* CDB[29], max status frame length, LSB */
#define ID50_CDB30_TIMEOUT_VALUE      (U8)0x46/* CDB[30], command timeout value */
#else
#define ID50_CDB25_PLAY_OPTION        (U8)0x00/* CDB[25], play option */
#define ID50_CDB26_SCANTIME           (U8)0x0A/* CDB[26], scan time */
#define ID50_CDB27_STS_FRM_LEN_H      (U8)0x80/* CDB[27], max status frame length, MSB */
#define ID50_CDB28_STS_FRM_LEN_L      (U8)0xC0/* CDB[28], max status frame length, LSB */
#define ID50_CDB29_TIMEOUT_VALUE      (U8)0x46/* CDB[29], command timeout value */
#endif
/* ID = 53H */
#define ID53_CDB7_MAX_FILES_NUM       (U8)0x27/* CDB[7]&[8], Maximum number of files: 9999 files */
#define ID53_CDB8_MAX_FILES_NUM       (U8)0x07
#define ID53_CDB9_MAX_FILES_NUM       (U8)0x03/* CDB[9]&[10], Maximum number of folders: 999 folders */
#define ID53_CDB10_MAX_FILES_NUM      (U8)0xE7
#define ID53_CDB11_MAX_TAG_LEN        (U8)0x00/* CDB[11]&[12], Maximum tag length: 128 bytes */
#define ID53_CDB12_MAX_TAG_LEN        (U8)0x80
#define ID53_CDB13_MAX_STS_FRM_LEN    (U8)0x81/* CDB[13]&[14], Maximum status frame length: 268 bytes */
#define ID53_CDB14_MAX_STS_FRM_LEN    (U8)0x0C
#define ID53_CDB15_MAX_FOLDER_LVL     (U8)0x07/* CDB[15], Maximum number of folder levels: 8 levels */
#define ID53_CDB16_IPOD_PWR_SUSPEND   (U8)0x00/* CDB[16]&[17], iPod power (suspend): 0 */
#define ID53_CDB17_IPOD_PWR_SUSPEND   (U8)0x00
#define ID53_CDB18_IPOD_PWR_NORMAL    (U8)0x00/* CDB[18]&[19], iPod power (normal): 0 */
#define ID53_CDB19_IPOD_PWR_NORMAL    (U8)0x00
#define ID53_CDB20_IPOD_PWR_ENABLE    (U8)0x00/* CDB[20], iPod power enable: Do not enable extra power */

/* Select root folder number */
#define ROOT_FOLDER_NUM               0x02/* NOTE: MODIFY BASED ON CMD(00H) CDB8 IN
                                               FUNCTION: sendCmd_USBSDConnection()
                                             root number based on file system turns
                                             0x01: when CMD(00H) CDB8 = 00H
                                             0x02: when CMD(00H) CDB8 except 00H */

/*****************************************************************************
 Imported global variables and functions (from other files)
 *****************************************************************************/

/*****************************************************************************
 Exported global variables and functions (to be accessed by other files)
 *****************************************************************************/

/*****************************************************************************
 Private variables and functions
 *****************************************************************************/
/* *** State related definition start *** */
/* AE1 task and sub-task state definition */
e_AE1Task EgAE1Task = AE1_POWER_DOWN;/* AE1 task state */
/* Playback sub-state definition */
static e_playSubstate EgplaySubstate = IDLE;

/* Save Need Power down information */
static BOOLEAN needPowerDown = FALSE;
/* Adjust volume */
static U16 attenuationValue = (U16) 0;

/*** Connect start ***/
/* AE1-L connect guard timer */
U32 U32gAE1ConnectGuardTimer = (U32) 0;
/*** Connect end ***/

/*** Switch file & folder start ***/
/* Switch folder number */
static S16 switchFolderNum = (S16) 0;
enum_getFolderInfoCtl_type getFolderInfoCtl;
static U16 folderBufNumPrevious = (U16) 0;/* Folder number information to be gotten before current folder */
static U16 folderBufNumAfter = (U16) 0;/* Folder number information to be gotten after current folder  */
static U16 specifiedFolderNum = (U16) 0;
static U8 updateFolderBufIndex = (U8) 0;
static BOOLEAN isFolderInfoComplete = TRUE;/* TRUE, folder information gotten complete
 FALSE, folder information gotten not complete */
/* Switch file number */
static S32 switchFileNum = (S32) 0;
static U16 currentNewFolderNum = (U16) 0;/* Save new folder number when switching file */
/* Get music information used */
static U16 InfoUpdatedFileNum = (U16) 0x0000;
/* Save playback time for judge invalid file type */
static U8 prevPlaybackTime = (U8) 0;
static U8 newPlaybackTime = (U8) 0;
/*** Switch file & folder end ***/

/*** To check whether can get music information or not start ***/
BOOLEAN vCanGetMusicInfo = FALSE;
/*** To check whether can get music information or not end ***/

/* Record command when do AE1 task */
static typeCmdHeader *RecCmd;

/* Record spontaneous STS when do AE1 task */
static stsConnectStatus_type stsConnectStatus;
static stsConnectStatus_type* pstsConnectStatus =
		(stsConnectStatus_type*) &U8AE1ComRxBuf[8];
static stsUsbSdConnection_type stsUsbSdConnection;
static stsUsbSdConnection_type* pstsUsbSdConnection =
		(stsUsbSdConnection_type*) &U8AE1ComRxBuf[7];
static stsPlayback_Pause_type stsPlayback_Pause;
static stsPlayback_Pause_type* pstsPlayback_Pause =
		(stsPlayback_Pause_type*) &U8AE1ComRxBuf[8];
static stsGetFolderInfo_type* pstsGetFolderInfo =
		(stsGetFolderInfo_type*) &U8AE1ComRxBuf[8];
static stsGetNameInfo_type* pstsGetNameInfo =
		(stsGetNameInfo_type*) &U8AE1ComRxBuf[8];
static stsGetTagInfo_type* pstsGetTagInfo =
		(stsGetTagInfo_type*) &U8AE1ComRxBuf[8];
static stsTimeInfo_type stsTimeInfo;
static stsTimeInfo_type* pstsTimeInfo = (stsTimeInfo_type*) &U8AE1ComRxBuf[7];
static stsMediaInfo_type* pstsMediaInfo =
		(stsMediaInfo_type*) &U8AE1ComRxBuf[8];
static stsROMInfo_type* pstsROMInfo = (stsROMInfo_type*) &U8AE1ComRxBuf[7];
static stsComSetupInfo_type* pstsComSetupInfo =
		(stsComSetupInfo_type*) &U8AE1ComRxBuf[7];
/* *** State related definition end *** */

/* *** Command transmission related variable definition start *** */
/* command counter
 * (range: 00H to 7FH)
 * when Direction bit = 0: Increment for each command issued from the host
 * when Direction bit = 1: Increment each time a spontaneous status frame is issued
 *  */
static U8 U8gcmdCounter = (U8) 0;

/* Check playback time in cycle loop */
U16 U16gDelayInCycle = (U16) 0;
/* Re-send command delay if previous STS parameters is invalid */
U16 U16gDelayResendCmd = (U16) 0;
/* Monitor playback time for switching next file if invalid file exists */
U16 U16gMonitorPlayTime = (U16) 0;

/* Playback/Pause command parameters */
static cmdPlayback_Pause_type cmdPlaybackPausePara =
{ (U16) 0x0000,/* Specified file/folder number */
(U16) 0x0000,/* Specified position, hour */
(U8) 0x00,/* Specified position, minute */
(U8) 0x00,/* Specified position, second */
{ (U8) 0x00, (U8) 0x00, (U8) 0x00, (U8) 0x00, (U8) 0x00 }/* Resume information */
};
/* Get folder command parameters */
static cmdGetFolderInfo_type cmdGetFolderInfo =
{ CURRENT_FOLDER,/* Current folder */
(U16) 0x0000, /* Specified folder number */
};

/* Name command parameters */
static cmdGetNameInfo_type cmdGetNameInfo =
{ (U8) 0x00,/* Target */
(U8) 0x00,/* Current */
(U16) 0x0000, /* Specified number */
};

/* Get Tag information command parameters */
static cmdGetTagInfo_type cmdGetTagInfo =
{ (U8) 0x00,/* tagType */
(U8) 0x00,/* target */
(U16) 0x0000, /* file number */
};

/* Temporary information for resume judgment */
static mediaInfo_type tempMediaInfo;/* Temporary media information */
/* Playback mode code based on host command
 *   PlaybackModeCodeTable[Random][Scan][Repeat]*/
static const U8 PlaybackModeCodeTable[2][2][5] =
{
{
{
/* | Random | Scan   |Repeat
 * | ON OFF | ON OFF |
 *      OFF      OFF        */MODE_FOLDER_NORMAL, /* SingleFolder */
MODE_FOLDER_REPEAT, /* CycleFolder */
MODE_ONE_FILE_REPEAT, /* SingleFile */
MODE_ALL_FILES_NORMAL, /* SingleAllFolder */
MODE_ALL_FILES_REPEAT /* CycleAllFolder */
},
{
/* | Random | Scan   |Repeat
 * | ON OFF | ON OFF |
 *      OFF   ON             */MODE_FOLDER_SCAN, /* SingleFolder */
MODE_FOLDER_REPEAT_SCAN, /* CycleFolder */
MODE_ONE_FILE_REPEAT, /* SingleFile */
MODE_ALL_FILES_SCAN, /* SingleAllFolder */
MODE_ALL_FILES_REPEAT_SCAN /* CycleAllFolder */
} },
{
{
/* | Random | Scan   |Repeat
 * | ON OFF | ON OFF |
 *      ON       OFF         */MODE_FOLDER_RANDOM, /* SingleFolder */
MODE_FOLDER_RANDOM_REPEAT, /* CycleFolder */
MODE_ONE_FILE_REPEAT, /* SingleFile */
MODE_ALL_FILES_RANDOM, /* SingleAllFolder */
MODE_ALL_FILES_RANDOM_REPEAT /* CycleAllFolder */
},
{
/* | Random | Scan   |Repeat
 * | ON OFF | ON OFF |
 *      ON    ON             */MODE_FOLDER_RANDOM_SCAN, /* SingleFolder */
MODE_FOLDER_RANDOM_REPEAT_SCAN, /* CycleFolder */
MODE_ONE_FILE_REPEAT, /* SingleFile */
MODE_ALL_FILES_RANDOM_SCAN, /* SingleAllFolder */
MODE_ALL_FILES_RANDOM_REPEAT_SCAN /* CycleAllFolder */
} } };
/* *** Command transmission related variable definition end *** */

/* *** Messages definition between host-AE1, display-AE1 task start *** */
/* === Messages: host -> AE1 === */
t_MsgHostToAE1 TMsgHostToAE1;
/* === Messages: display -> AE1 === */
/* === MessageA: AE1 -> display === */
t_AE1MsgForDisplay AE1MsgForDisplay;
/* *** Messages definition between host-AE1, display-AE1 task end *** */

/* *** Save Resume/Current playback information start *** */
/* Media resume information */
resumeMediaInfo_type resumeMediaInfo;
/* Current play information */
static currentPlayInfo_type currentPlayInfo =
{
/* Current folder related */
(U16) 0x0000,/* Folder number which current file is contained to */
(U16) 0x0000,/* Total file number in current folder */
(U16) 0x0000,/* First file number in current folder */
(U16) 0x0000,/* Current file position in current folder */
{ UNKOWN_CODE, (U8) 0x00,
{ (U8) 0x00, } },/* File name information */

/* Resume information */
/* Media information */
{ (U16) 0x0000,/* Total folder number */
(U16) 0x0000,/* Total file number */
(U32) 0x0000,/* VoumeID */
{ (U8) 0x00, (U8) 0x00, (U8) 0x00, (U8) 0x00, (U8) 0x00, (U8) 0x00, (U8) 0x00,
		(U8) 0x00 },/* File size */

/* File related */
(U16) 0x0000,/* Current file number */
{ (U16) 0x0000, (U8) 0x00, (U8) 0x00 },/* Current playback/pause time information */

/* Resume info related[reserved] */
{ (U8) 0x00, (U8) 0x00, (U8) 0x00, (U8) 0x00, (U8) 0x00 },/* Resume information */

/* Media related */
(U8) USB, /* Device information */
{
{ (U16) 0x00 },
{ (U16) 0x00 },
{ (U16) 0x00 } }/* Media information */
} };
/* *** Save Resume/Current playback information end *** */

/* *** Save current media information start *** */
/* Media list supported table */
static U8 mediaListTable[MEDIA_NUMBERS] =
{ MEDIA_TYPE_USB,
#ifdef SD_USED
		MEDIA_TYPE_SD
#endif
		};

/* Current media status information definition */
static mediaStatus_type currentMediaStatus =
{
/* USB media */
{ DISCONNECTED, /* Connection */
FALSE,/* File is invalid */
(U16) 0x0000,/* TotalFileNum */
(U16) 0x0000,/* TotalFolderNum */
(U32) 0x00,/* volumeID */
{ (U8) 0x00, }/* fileSize */
},
#ifdef SD_USED
/* SD media */
{ DISCONNECTED, /* Connection */
FALSE,/* File is invalid */
(U16) 0x0000,/* TotalFileNum */
(U16) 0x0000, /* TotalFolderNum */
(U32) 0x00,/* volumeID */
{ (U8) 0x00, }/* fileSize */
},
#endif
/* Other media */
};
/* *** Save current media information start *** */


/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(tag information-title, version & code)
 * Include           : none
 * Declaration       : static void SetTagVersionAndCode_title(void)
 * Description       : update display(tag information-title)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void SetTagVersionAndCode_title(void)
{
	/* Version */
	switch (pstsGetTagInfo->version)
	{
	case IDB1_VER_ID3V22:
		AE1MsgForDisplay.currentFile.tagInfo.title.version = ID3V22;
		break;
	case IDB1_VER_ID3V23:
		AE1MsgForDisplay.currentFile.tagInfo.title.version = ID3V23;
		break;
	case IDB1_VER_ID3V24:
		AE1MsgForDisplay.currentFile.tagInfo.title.version = ID3V24;
		break;
	case IDB1_VER_ID3V10:
		AE1MsgForDisplay.currentFile.tagInfo.title.version = ID3V10;
		break;
	case IDB1_VER_ID3V11:
		AE1MsgForDisplay.currentFile.tagInfo.title.version = ID3V11;
		break;
	case IDB1_VER_WMA:
		AE1MsgForDisplay.currentFile.tagInfo.title.version = WMACONTENTS;
		break;
	case IDB1_VER_MP4:
		AE1MsgForDisplay.currentFile.tagInfo.title.version = MP4CONTENTS;
		break;
	case IDB1_VER_WAV:
		AE1MsgForDisplay.currentFile.tagInfo.title.version = WMACONTENTS;
		break;
	default:
		/* Other version word */
		break;
	}

	/* Character code */
	switch (pstsGetTagInfo->wordCode)
	{
	case IDB1_CHAR_CODE_UNKOWN:
		AE1MsgForDisplay.currentFile.tagInfo.title.characterCode = UNKOWN;
		break;
	case IDB1_CHAR_CODE_UTF16_LE:
		AE1MsgForDisplay.currentFile.tagInfo.title.characterCode
				= UNICODE_UTF16_LE;
		break;
	case IDB1_CHAR_CODE_UTF16_BE:
		AE1MsgForDisplay.currentFile.tagInfo.title.characterCode
				= UNICODE_UTF16_BE;
		break;
	case IDB1_CHAR_CODE_UTF8:
		AE1MsgForDisplay.currentFile.tagInfo.title.characterCode = UNICODE_UTF8;
		break;
	case IDB1_CHAR_CODE_UTF16_WITH_BOM:
		AE1MsgForDisplay.currentFile.tagInfo.title.characterCode
				= UNICODE_UTF16_WITH_BOM;
		break;
	case IDB1_CHAR_CODE_ISO8859:
		AE1MsgForDisplay.currentFile.tagInfo.title.characterCode = ISO8859;
		break;
	case IDB1_CHAR_CODE_EXCEPTION:
		AE1MsgForDisplay.currentFile.tagInfo.title.characterCode = EXCEPTION;
		break;
	default:
		/* To do: process other value words if necessary */
		break;
	}
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(tag information-artist, version & code)
 * Include           : none
 * Declaration       : static void SetTagVersionAndCode_artist(void)
 * Description       : update display(tag information-title)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void SetTagVersionAndCode_artist(void)
{
	/* Version */
	switch (pstsGetTagInfo->version)
	{
	case IDB1_VER_ID3V22:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.version = ID3V22;
		break;
	case IDB1_VER_ID3V23:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.version = ID3V23;
		break;
	case IDB1_VER_ID3V24:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.version = ID3V24;
		break;
	case IDB1_VER_ID3V10:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.version = ID3V10;
		break;
	case IDB1_VER_ID3V11:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.version = ID3V11;
		break;
	case IDB1_VER_WMA:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.version = WMACONTENTS;
		break;
	case IDB1_VER_MP4:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.version = MP4CONTENTS;
		break;
	case IDB1_VER_WAV:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.version = WMACONTENTS;
		break;
	default:
		/* Other version word */
		break;
	}

	/* Character code */
	switch (pstsGetTagInfo->wordCode)
	{
	case IDB1_CHAR_CODE_UNKOWN:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.characterCode = UNKOWN;
		break;
	case IDB1_CHAR_CODE_UTF16_LE:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.characterCode
				= UNICODE_UTF16_LE;
		break;
	case IDB1_CHAR_CODE_UTF16_BE:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.characterCode
				= UNICODE_UTF16_BE;
		break;
	case IDB1_CHAR_CODE_UTF8:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.characterCode
				= UNICODE_UTF8;
		break;
	case IDB1_CHAR_CODE_UTF16_WITH_BOM:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.characterCode
				= UNICODE_UTF16_WITH_BOM;
		break;
	case IDB1_CHAR_CODE_ISO8859:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.characterCode = ISO8859;
		break;
	case IDB1_CHAR_CODE_EXCEPTION:
		AE1MsgForDisplay.currentFile.tagInfo.artistName.characterCode
				= EXCEPTION;
		break;
	default:
		/* To do: process other value words if necessary */
		break;
	}
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Update message for display(tag information-album, version & code)
 * Include           : none
 * Declaration       : static void SetTagVersionAndCode_album(void)
 * Description       : update display(tag information-title)
 * Argument          : none
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void SetTagVersionAndCode_album(void)
{
	/* Version */
	switch (pstsGetTagInfo->version)
	{
	case IDB1_VER_ID3V22:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.version = ID3V22;
		break;
	case IDB1_VER_ID3V23:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.version = ID3V23;
		break;
	case IDB1_VER_ID3V24:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.version = ID3V24;
		break;
	case IDB1_VER_ID3V10:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.version = ID3V10;
		break;
	case IDB1_VER_ID3V11:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.version = ID3V11;
		break;
	case IDB1_VER_WMA:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.version = WMACONTENTS;
		break;
	case IDB1_VER_MP4:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.version = MP4CONTENTS;
		break;
	case IDB1_VER_WAV:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.version = WMACONTENTS;
		break;
	default:
		/* Other version word */
		break;
	}

	/* Character code */
	switch (pstsGetTagInfo->wordCode)
	{
	case IDB1_CHAR_CODE_UNKOWN:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.characterCode = UNKOWN;
		break;
	case IDB1_CHAR_CODE_UTF16_LE:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.characterCode
				= UNICODE_UTF16_LE;
		break;
	case IDB1_CHAR_CODE_UTF16_BE:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.characterCode
				= UNICODE_UTF16_BE;
		break;
	case IDB1_CHAR_CODE_UTF8:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.characterCode
				= UNICODE_UTF8;
		break;
	case IDB1_CHAR_CODE_UTF16_WITH_BOM:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.characterCode
				= UNICODE_UTF16_WITH_BOM;
		break;
	case IDB1_CHAR_CODE_ISO8859:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.characterCode = ISO8859;
		break;
	case IDB1_CHAR_CODE_EXCEPTION:
		AE1MsgForDisplay.currentFile.tagInfo.AlbumName.characterCode
				= EXCEPTION;
		break;
	default:
		/* To do: process other value words if necessary */
		break;
	}
}
#ifdef RESUME_FUNCTION_USED

/*****************************************************************************
 * ID                : 1.0
 * Outline           : Save current play information to resume media information
 * Include           : none
 * Declaration       : static void SaveResumeInfo(U8 mediaType)
 * Description       : Save current play information to resume media information
 *                   :
 * Argument          : mediaType, specified USB/SD
 * Return Value      : none
 * Calling Functions : none
 *****************************************************************************/
static void SaveResumeInfo(U8 mediaType)
{
	if (mediaType == MEDIA_TYPE_USB)
	{
		/* Save to USB media resume information */
		resumeMediaInfo.usbResumeInfo = currentPlayInfo.resumeInfo;
	}
#ifdef SD_USED
	else if (mediaType == MEDIA_TYPE_SD)
	{
		/* Save to SD media resume information */
		resumeMediaInfo.sdResumeInfo = currentPlayInfo.resumeInfo;
	}
#endif
	else
	{
		/* Save to other media resume information */
	}
}

#endif



/*****************************************************************************
 * ID                : 1.0
 * Outline           : To get media number on media list table
 * Include           : none
 * Declaration       : static U8 GetNextMediaNum(U8 specifiedMediaType)
 * Description       : To get media number on media list table
 * Argument          : specifiedMediaType, specified media type.
 * Return Value      : media number in media list table
 * Calling Functions : none
 *****************************************************************************/
static U8 GetNextMediaNum(U8 specifiedMediaType)
{
	U8 mediaTableIndex = (U8) 0;
	U8 returnValue = (U8) 0xFF;

	for (mediaTableIndex = (U8) 0; mediaTableIndex < (sizeof(mediaListTable)
			/ sizeof(mediaListTable[0])); mediaTableIndex++)
	{
		if (specifiedMediaType == mediaListTable[mediaTableIndex])
		{
			/* Specified media number was found in table */
			if (mediaTableIndex == ((sizeof(mediaListTable)
					/ sizeof(mediaListTable[0])) - (U8) 1))
			{
				/* If specified media is the last media in table
				 * point to the first media */
				returnValue = (U8) 0x00;
			}
			else
			{
				/* If specified media is not the last media in table
				 * then point to next media in table */
				returnValue = mediaTableIndex + (U8) 1;
			}
			break;
		}
		else
		{
			/* Continue to find the current media number */
		}
	}

	return returnValue;
}

/*****************************************************************************
 * ID                : 1.0
 * Outline           : To check specified media validity
 * Include           : none
 * Declaration       : static U8 GetMediaNum(U8 specifiedMediaNum)
 * Description       : To check specified media validity
 * Argument          : specifiedMediaNum, specified media number on media list table
 * Return Value      : TRUE, if specified media is valid
 *                   : FALSE, if specified media is not valid
 * Calling Functions : none
 *****************************************************************************/
static BOOLEAN IsMediaValid(U8 specifiedMediaNum)
{
	BOOLEAN returnValue = FALSE;

	switch (mediaListTable[specifiedMediaNum])
	{
	case MEDIA_TYPE_USB:
		/* Check USB validity */
		if (currentMediaStatus.usb.connectSts == CONNECTED)
		{
			returnValue = TRUE;
		}
		else
		{
			/* If USB is not valid or total file number in USB is 0 */
			returnValue = FALSE;
		}
		break;
#ifdef SD_USED
	case MEDIA_TYPE_SD:
		/* Check SD validity */
		if (currentMediaStatus.sd.connectSts == CONNECTED)
		{
			returnValue = TRUE;
		}
		else
		{
			/* If SD is not valid or total file number in SD is 0 */
			returnValue = FALSE;
		}
		break;
#endif
	default:
		/* Not valid media */
		returnValue = FALSE;
		break;
	}

	return returnValue;
}



/* End of file */
