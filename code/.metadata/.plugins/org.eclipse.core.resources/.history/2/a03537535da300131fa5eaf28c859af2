/***********************************************************************/
/*                                                                     */
/*  FILE        :intprg.c                                              */
/*  DATE        :Tue, Dec 14, 2010                                     */
/*  DESCRIPTION :define the top address of the interrupt vectors.      */
/*  CPU GROUP   :2A                                                    */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.18).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/***********************************************************************/

/***************************************************************************
* COMPILER for M16C/60,R8C/Tiny
* Copyright (C) 2004 (2010) Renesas Electronics Corporation.
* and Renesas Solutions Corporation. All rights reserved.
* intprg.c : define variable vector table
*            for R8C/22,23
*
*
* $Date: 2007/05/24 06:50:18 $
* $Revision: 1.2.8.2 $
**************************************************************************/
#include "sfr_r82b.h"
#include "cstartdef.h"
#include "driver_iic.h"
#include "driver_timer0.h"
#include "driver_timer1.h"
#include "driver_int.h"
//#include "driver_csi0.h"
// When you want to use BANK1 registers
// please define interrupt using /B swtich as follows.
//
//  #pragma interrupt/B xxxx
//

// BRK				(software int 0)
#pragma interrupt	_brk(vect=0)
void _brk(void);
void _brk(void){}

// vector 1 reserved
// vector 2 reserved
// vector 3 reserved
// vector 4 reserved
// vector 5 reserved
// vector 6 reserved


// timer RC 			(software int 7)
#pragma interrupt	_timer_rc(vect=7)
void _timer_rc(void);
void _timer_rc(void){}

// timer RD (channel 0)		(software int 8)
#pragma interrupt	_timer_rd0(vect=8)
void _timer_rd0(void);
void _timer_rd0(void){}

// timer RD (channel 1)		(software int 9)
#pragma interrupt	_timer_rd1(vect=9)
void _timer_rd1(void);
void _timer_rd1(void){}

// timer RE			(software int 10)
#pragma interrupt	_timer_re(vect=10)
void _timer_re(void);
void _timer_re(void){}

// uart2 trance			(software int 11)
#pragma interrupt	_uart2_trance(vect=11)
void _uart2_trance(void);
void _uart2_trance(void){}

// uart2 receive		(software int 12)
#pragma interrupt	_uart2_receive(vect=12)
void _uart2_receive(void);
void _uart2_receive(void){}

// input_key			(software int 13)
#pragma interrupt	_input_key(vect=13)
void _input_key(void);
void _input_key(void){}

// vector 14 reserved

// SSUIC/IICIC			(software int 15)
#pragma interrupt	_ssuic(vect=15)
void _ssuic(void);
void _ssuic(void){Drv_I2C_Int();}

// compare1			(software int 16)
#pragma interrupt	_compare1(vect=16)
void _compare1(void);
void _compare1(void){TmrRFInt();}

#if __STANDARD_IO__ == 0
// uart0 trance			(software int 17)
#pragma interrupt	_uart0_trance(vect=17)
void _uart0_trance(void);
//void _uart0_trance(void){CSI0TransmitInt();}
void _uart0_trance(void){}
#else
#if (defined(__FOUSB__) || defined(__E8__))
// uart0 can't be used
#else
// uart0 trance			(software int 17)
#pragma interrupt	_uart0_trance(vect=17)
void _uart0_trance(void);
void _uart0_trance(void){}
#endif
#endif

// uart0 receive		(software int 18)
#pragma interrupt	_uart0_receive(vect=18)
void _uart0_receive(void);
//void _uart0_receive(void){CSI0ReceiveInt();}
void _uart0_receive(void){}

#if __STANDARD_IO__ == 1
// uart1 can't be used
#else
#if defined(__FOUSB__) || defined(__E8__)
// uart1 can't be used
#else
// uart1 trance			(software int 19)
#pragma interrupt	_uart1_trance(vect=19)
void _uart1_trance(void);
void _uart1_trance(void){}
#endif
#endif

// uart1 receive		(software int 20)
#pragma interrupt	_uart1_receive(vect=20)
void _uart1_receive(void);
void _uart1_receive(void){}

// int2				(software int 21)
#pragma interrupt	_int2(vect=21)
void _int2(void);
void _int2(void){INT2Int();}

// timer RA			(software int 22)
#pragma interrupt	_timer_ra(vect=22)
void _timer_ra(void);
void _timer_ra(void){TmrRAInt();}

// vector 23 reserved

// timer RB			(software int 24)
#pragma interrupt	_timer_rb(vect=24)
void _timer_rb(void);
void _timer_rb(void){/*TmrRBInt();*/}

// int1				(software int 25)
#pragma interrupt	_int1(vect=25)
void _int1(void);
void _int1(void){INT1Int();}

// int3				(software int 26)
#pragma interrupt	_int3(vect=26)
void _int3(void);
void _int3(void){INT3Int();}

// timer RF			(software int 27)
#pragma interrupt	_timer_rf(vect=27)
void _timer_rf(void);
void _timer_rf(void){}

// compare0 			(software int 28)
#pragma interrupt	_compare0(vect=28)
void _compare0(void);
void _compare0(void){}

// int0				(software int 29)
#pragma interrupt	_int0(vect=29)
void _int0(void);
void _int0(void){INT0Int();}

// AD converter			(software int 30)
#pragma interrupt	_ad_converter(vect=30)
void _ad_converter(void);
void _ad_converter(void){}

// capture			(software int 31)
#pragma interrupt	_capture(vect=31)
void _capture(void);
void _capture(void){}

// vector 32 for user
// vector 33 for user
// vector 34 for user
// vector 35 for user
// vector 36 for user
// vector 37 for user
// vector 38 for user
// vector 39 for user
// vector 40 for user
// vector 41 for user
// vector 42 for user
// vector 43 for user
// vector 44 for user
// vector 45 for user
// vector 46  for user
// vector 47  for user
// vector 48  for user
// vector 49  for user
// vector 50  for user
// vector 51  for user
// vector 52  for user
// vector 53  for user
// vector 54  for user
// vector 55  for user
// vector 56  for user
// vector 57  for user
// vector 58  for user
// vector 59  for user
// vector 60  for user
// vector 61  for user
// vector 62  for user
// vector 63  for user

